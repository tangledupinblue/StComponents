module Components.FormHolders

open System
open Fable.Core
open Elmish.React
open Fable.React
open Fable.React.Props
open Fetch
open Thoth.Json

open Components.FormControls

// NB - be careful with decimal types
// Notes from Thoth.Json
// ### Decoding int64, decimal or bigint
//Coders for `int64`, `decimal` or `bigint` won't be automatically generated by default. 
//If they were, the bundle size would increase significantly even if you don't intend to use these types.

// type SelectOption<'a> = {
//     Key: 'a
//     Value: string
// }
//     with 
//         static member empty = { Key= Unchecked.defaultof<'a> ; Value= "" }
//         static member findInList lst k = 
//                 List.tryFind (fun x -> x.Key = k) lst 
//                 |> Option.defaultValue SelectOption.empty
//                 |> (fun x -> x.Key)

// type SelectOptionString = SelectOption<string>

//NB - not all layouts supported for all types ; if not supported will switch to Default
type Layout =
    | Default = 0
    | DropDown = 1
    | Buttons = 2
    | RadioButtons = 3
    | Checklist = 4
    | Stars = 5


type KeyType = 
    | StringKey
    | IntKey
    // | GuidKey

type OptionKey = {
    Key: string
    KeyType: KeyType
}
    with 
        static member string str = { Key= str ; KeyType= StringKey } 
        static member int str = { Key= str ; KeyType= IntKey } 
        //static member guid str = { Key= str ; KeyType= GuidKey } 

type SelectOptionString = {
    Key: string
    Value: string
}

type IntTimeSpan = {
    Days: int
    Hours: int
    Minutes: int
}
    with 
        static member empty = { Days= 0 ; Hours= 0 ; Minutes= 0 }
        static member isEmpty ts = ts.Days = 0 && ts.Hours = 0 && ts.Minutes = 0


// type SelectOptionString = {
//     Key: string
//     Value: string
// }
//     with 
//         static member empty = { Key= "" ; Value= "" }
//         static member findInList (lst:SelectOptionString list) k = 
//                 List.tryFind (fun x -> x = k) lst 
//                 |> Option.defaultValue SelectOptionString.empty
//                 |> (fun x -> x.Key)

// type SelectOptionInt = {
//     Key: int
//     Value: string
// }

//TODO - implement this as a separate namespace that uses the ValueHolders
// type FormQuestion = {
//     FieldId: string
//     DisplayText: string
//     ResponseFloat: float option
//     ResponseString: string option
//     ResponseOptions: string list option
// }

// module Convert = 
//     let stringToInt context str =
//         match Int32.TryParse str with
//             | true, i -> i
//             | _ ->  failwith <| sprintf "Expecting a number value for %s but got %s instead" context str


type FloatValue = {
    Display: string
    Value: float
}
    with 
        static member fromFloat flt = 
                            {   Display= if flt = 0. then "0" else sprintf "%.2f" flt
                                Value= flt }
        static member zero = { Display= "0" ; Value= 0. }

type ValueHolder =
    | String of string
    | Text of string
    | Message of string   
    | Password of string 
    // | Select of string*string
    | SelectString of OptionKey*SelectOptionString list 
    // | RadioButtonsString of OptionKey*SelectOptionString list
    | SelectManyStrings of string*SelectOptionString list
    | BitString of string*string list    
    | DateString of string
    | TimeString of string
    | Hidden of ValueHolder //string
    //| Decimal of decimal //this can sometimes cause problems with Thoth.Json - 
    | Float of FloatValue //(string*float)
    //| Double of double
    | Int of int
    | Bool of bool
    | TimeSpanInt of int*IntTimeSpan  //time span in minutes
    with
        static member float flt = FloatValue.fromFloat flt |> Float
        static member intFromStrings sel (options:(int*string) list) = 
            options
                |> List.map (fun (k,v) -> { Key = string k ; Value = v })
                |> (fun opts -> { Key= string sel ; KeyType= IntKey }, opts )
                |> SelectString           
        static member stringFromStrings sel (options:(string*string) list) =
            options
                |> List.map (fun (k,v) -> { Key = string k ; Value = v })
                |> (fun opts -> { Key= string sel ; KeyType= StringKey }, opts )
                |> SelectString           
        static member stringsFromStrings sel (options:(string*string) list) =
            options
                |> List.map (fun (k,v) -> { Key = string k ; Value = v })
                |> (fun opts -> sel, opts )
                |> SelectManyStrings           
                 
type InputBehaviour = 
    | Default
    | Optional
    | Required
    | ReadOnly

let splitCamelCase (str:string) = 
    str.ToCharArray()     
        |> Array.fold (fun s c -> match Char.IsUpper c, fst s |> String.length, snd s |> String.length with
                                    | _, 0, 0 -> "", sprintf "%c" (c |> Char.ToUpper)
                                    | true, _, _ -> fst s, sprintf "%s%c" (snd s) c                 //(snd s) + (sprintf "%c" c)  
                                    | false, 0, _ -> sprintf "%s%s%c" (fst s) (snd s) c, ""         //(fst s) + (snd s) + (sprintf "%c" c), ""
                                    | false, _, 0 -> sprintf "%s%c" (fst s) c, ""                   //(fst s) + (sprintf "%c" c), "" 
                                    | false, _, _ -> sprintf "%s %s%c" (fst s) (snd s) c, ""  )     //(fst s) + " " + (snd s) + (sprintf "%c" c), "" )
                        ("","")
        |> (fun (x,y) -> x + (if String.length y > 0 then " " + y else "" ) )


type FieldHolder = {
    ControlId: string           //unique id for control - use in instances where there is more than one of the same form
    FieldId: string             //name of the field - this will be what is used when converted to json
    DisplayName: string         //what the user sees
    Value: ValueHolder   
    Behaviour: InputBehaviour
    Layout: Layout
}
    with 
        static member empty = { ControlId=""; FieldId=""; DisplayName=""; Value= String ""; Behaviour= Default ; Layout= Layout.Default  }
        static member create name value = 
                { ControlId= name; FieldId= name; DisplayName= splitCamelCase name; 
                Value= value; Behaviour= Required ; Layout= Layout.Default  }
        static member createId fieldId display value = 
                { ControlId= fieldId; FieldId= fieldId; DisplayName= splitCamelCase display; 
                Value= value; Behaviour= Required ; Layout= Layout.Default  }        
        static member createBehaviour name value behaviour = 
                { ControlId= name; FieldId= name ; DisplayName= splitCamelCase name; 
                Value= value; Behaviour= behaviour ; Layout= Layout.Default  }
        static member createHiddenString name strValue =    {   ControlId= name; FieldId= name; DisplayName= ""; 
                                                                Value= String strValue |> Hidden; Behaviour= Default ;
                                                                Layout= Layout.Default }
        static member createHiddenInt name intValue =       {   ControlId= name; FieldId= name; DisplayName= ""; 
                                                                Value= Int intValue |> Hidden; Behaviour= Default ;
                                                                Layout= Layout.Default }
        static member createHiddenFloat name fltValue =     {   ControlId= name; FieldId= name; DisplayName= "";
                                                                Value= ValueHolder.float fltValue |> Hidden ; Behaviour= Default ;
                                                                Layout= Layout.Default }
        static member createMessage msg =                   {   ControlId= "message"; FieldId= msg; DisplayName= "";
                                                                Value= Message msg ; Behaviour= Default ;
                                                                Layout= Layout.Default }
        static member setBehaviour behaviour fh = { fh with Behaviour= behaviour }
        static member setLayout layout fh = { fh with Layout= layout }

        static member valueAsString fieldholder =
            let rec getString fh=
                match fh with 
                    | String s | Text s | Message s | Password s | DateString s | TimeString s -> s
                    | BitString (s,_)  
                    | SelectManyStrings (s,_) -> s
                    | SelectString (s,_) -> s.Key
                    //| Decimal d -> sprintf "%.2f" d
                    // | Double d 
                    | Float d -> d.Display //sprintf "%.2f" (snd d)
                    | Int i -> i.ToString()
                    | TimeSpanInt (i,_) -> i.ToString()
                    | Bool b -> b.ToString()
                    | Hidden vh -> getString vh
            getString fieldholder.Value


        static member valueAsBool fieldholder = 
            let rec getBool fh =
                match fh with 
                    | String s | Message s | Text s -> 
                        if (s.ToLower()) = "true" then true
                        else if (s.ToLower()) = "false" then false
                        else failwith <| sprintf "Expecting a boolean value for %s but got %s instead" fieldholder.DisplayName s
                    //| Decimal d -> failwith <| sprintf "Expecting a boolean value for %s but got %f instead" fieldholder.DisplayName d
                    // | Double d 
                    | Password s -> failwith <| sprintf "Expecting a boolean value for %s but got %s instead" fieldholder.DisplayName "password"
                    | Float d -> failwith <| sprintf "Expecting a boolean value for %s but got %f instead" fieldholder.DisplayName (d.Value)
                    | Int i -> failwith <| sprintf "Expecting a boolean value for %s but got %i instead" fieldholder.DisplayName i
                    | Bool b -> b
                    | Hidden s -> getBool s  
                    | _ -> failwith <| sprintf "Cannot convert value for %s of %A to %s" fieldholder.DisplayName fieldholder.Value "bool"
            getBool fieldholder.Value

        // static member valueAsDecimal fieldholder = 
        //     let rec getDecimal fh =
        //         match fh with 
        //             | String s | Text s -> 
        //                 match Decimal.TryParse(s) with
        //                     | true, d -> d
        //                     | _ -> failwith <| sprintf "Expecting a decimal value for %s but got %s instead" fieldholder.DisplayName s
        //             //| Decimal d -> d
        //             // | Double d 
        //             | Float d ->  Convert.ToDecimal(d)
        //             | Int i ->  Convert.ToDecimal(i)
        //             | Bool b -> failwith <| sprintf "Expecting a decimal value for %s but got %b instead" fieldholder.DisplayName b
        //             | Hidden s -> getDecimal s
        //             | _ -> failwith <| sprintf "Cannot convert value for %s of %A to %s" fieldholder.DisplayName fieldholder.Value "decimal"
        //     getDecimal fieldholder.Value

        static member valueAsFloat fieldholder =
            let rec getDouble fh =
                match fh with 
                    | String s | Message s | Text s -> 
                        match Double.TryParse(s) with
                            | true, d -> d
                            | _ -> failwith <| sprintf "Expecting a decimal value for %s but got %s instead" fieldholder.DisplayName s
                    //| Decimal d -> Convert.ToDouble(d)
                    // | Double d 
                    | Password s -> failwith <| sprintf "Expecting a boolean value for %s but got %s instead" fieldholder.DisplayName "password"
                    | Float d ->  d.Value
                    | Int i ->  Convert.ToDouble(i)
                    | Bool b -> failwith <| sprintf "Expecting a decimal value for %s but got %b instead" fieldholder.DisplayName b
                    | Hidden s -> getDouble s
                    | _ -> failwith <| sprintf "Cannot convert value for %s of %A to %s" fieldholder.DisplayName fieldholder.Value "float"
            getDouble fieldholder.Value

        static member valueAsInt fieldholder =
            let rec getInt fh =
                match fh with 
                    | String s | Message s | Text s -> 
                        match Int32.TryParse(s) with
                            | true, i -> i
                            | _ -> failwith <| sprintf "Expecting a number value for %s but got %s instead" fieldholder.DisplayName s
                    //| Decimal d -> Convert.ToInt32(d)
                    // | Double d 
                    | Password s -> failwith <| sprintf "Expecting a boolean value for %s but got %s instead" fieldholder.DisplayName "password"
                    | Float d -> Convert.ToInt32(d.Value)
                    | Int i -> i
                    | TimeSpanInt (i,_) -> i
                    | Bool b -> failwith <| sprintf "Expecting a number value for %s but got %b instead" fieldholder.DisplayName b
                    | Hidden s -> getInt s
                    | _ -> failwith <| sprintf "Cannot convert value for %s of %A to %s" fieldholder.DisplayName fieldholder.Value "int"
            getInt fieldholder.Value        
            

type Msg = 
    | ValueChanged of FieldHolder


type ValidationMessages = {
    Required: string
}
    with 
        static member none = { Required= "" }
        static member default_ = { Required= "Required" }        

type FormHolder = {
    FormId: string
    Caption: string
    Fields: FieldHolder list
    ValidationMessages: ValidationMessages
    Validations: (FormHolder -> Result<bool,string>) list
}
    with 
        static member empty = { FormId= Guid.NewGuid().ToString(); Caption= "Loading..."; Fields= []; ValidationMessages= { Required= "" } ; Validations= [] }
        static member createSimple caption fieldHolders = {
                                                FormId= "formholder"
                                                Caption= caption
                                                Fields= fieldHolders
                                                ValidationMessages= ValidationMessages.default_
                                                Validations= []
                                            }
        static member addValidation func formHolder =
            { formHolder with Validations = List.append formHolder.Validations [ func ] }

        static member setStringLookup (holder:FormHolder) (fieldId:string)  (lookupVals:SelectOptionString list) =
            match holder.Fields |> List.tryFind (fun x -> x.FieldId = fieldId) with
            | Some f ->
                match f.Value with
                | SelectString (v,_) -> 
                    { holder with Fields =
                                    holder.Fields
                                    |> List.map (fun x -> if x.FieldId = f.ControlId then { f with Value= SelectString(v,lookupVals) }
                                                            else x ) } 
                | _ -> holder
            | None -> holder

        static member valueAsString (holder:FormHolder) (controlId:string) = 
            match holder.Fields |> List.tryFind (fun x -> x.FieldId = controlId) with
                | Some f -> FieldHolder.valueAsString f
                | None -> failwith <| sprintf "No value for %s was found" controlId 
        // static member valueAsDecimal (holder:FormHolder) (controlId:string) = 
        //     match holder.Fields |> List.tryFind (fun x -> x.FieldId = controlId) with
        //         | Some f -> FieldHolder.valueAsDecimal f
        //         | None -> failwith <| sprintf "No value for %s was found" controlId 
        static member valueAsFloat (holder:FormHolder) (controlId:string) = 
            match holder.Fields |> List.tryFind (fun x -> x.FieldId = controlId) with
                | Some f -> FieldHolder.valueAsFloat f
                | None -> failwith <| sprintf "No value for %s was found" controlId 
        static member valueAsInt (holder:FormHolder) (controlId:string) =
            match holder.Fields |> List.tryFind (fun x -> x.FieldId = controlId) with
                | Some f -> FieldHolder.valueAsInt f
                | None -> failwith <| sprintf "No value for %s was found" controlId 
        static member valueAsBoolean (holder:FormHolder) (controlId:string) =
            match holder.Fields |> List.tryFind (fun x -> x.FieldId = controlId) with
                | Some f -> FieldHolder.valueAsBool f
                | None -> failwith <| sprintf "No value for %s was found" controlId 

let jsonEncodeValue (valueHolder:ValueHolder) =
    let rec getJson holder= 
        match holder with
            | String str | Message str | Text str | Password str | DateString str | TimeString str -> Encode.string str  
            //| Decimal flt -> Convert.ToDouble flt |> Encode.float  //Encode.decimal flt
            // | Double flt 
            | Float flt -> Encode.float (flt.Value)
            | Int i -> Encode.int i
            | TimeSpanInt (i,_) -> Encode.int i
            | Bool bl -> Encode.bool bl        
            | Hidden str -> getJson str
            | BitString (str,_)  
            | SelectManyStrings (str,_) -> Encode.string str
            | SelectString (k,_) -> 
                match k.KeyType with
                    | StringKey -> Encode.string k.Key
                    | IntKey -> match Int32.TryParse k.Key with
                                    | true, i -> Encode.int i
                                    | _ ->  failwith <| sprintf "Expecting a number value for json but got %s instead" k.Key
    getJson valueHolder

let jsonEncodeValueList (fields: FieldHolder list) =
    Encode.object (
        fields
            |> List.map (fun x -> x.FieldId, jsonEncodeValue x.Value )
    )

let jsonEncodeForm (instance:FormHolder) = 
    instance.Fields |> jsonEncodeValueList

let inline formToType<'a> (fh:FormHolder) =
    jsonEncodeForm fh 
    //|> (fun x -> Console.WriteLine(x) ; x )
    |> Thoth.Json.Encode.toString 4 
    |> Thoth.Json.Decode.Auto.fromString<'a>

let getFieldFromList (fields: FieldHolder list) (id:string) =
    fields |> List.filter (fun x -> x.ControlId = id) |> List.tryHead |> Option.defaultValue FieldHolder.empty

let getField (instance:FormHolder) (id:string) = 
    // instance.Fields |> List.filter (fun x -> x.ControlId = id) |> List.tryHead |> Option.defaultValue FieldHolder.empty
    getFieldFromList instance.Fields id

let updateFieldInList (fields: FieldHolder list) (newField: FieldHolder) =
    fields |> List.map (fun x -> if x.ControlId = newField.ControlId then newField else x)


let updateFieldByControlId (fields:FieldHolder list) (controlid:string) (newValue:ValueHolder) =
    fields |> List.map (fun x ->    
                                    if x.ControlId = controlid then 
                                        { x with Value= newValue }
                                    else x)

let updateField (frm:FormHolder) (newField:FieldHolder) =
    { 
        FormId= frm.FormId
        Caption= frm.Caption
        Fields= updateFieldInList frm.Fields newField 
        ValidationMessages = frm.ValidationMessages
        Validations= frm.Validations
    }

let updateValue (msg:Msg) (frm:FormHolder) : FormHolder = 
    match msg with
        | ValueChanged fld -> updateField frm fld

let updateStringField (f:FieldHolder) (newText:string) =
//     { ControlId= f.ControlId; FieldId = f.FieldId; FieldName= f.FieldName; Value= String newText; Required= f.Required }
    { f with Value = String newText }

let updatePasswordField (f:FieldHolder) (newText:string) =
//     { ControlId= f.ControlId; FieldId = f.FieldId; FieldName= f.FieldName; Value= String newText; Required= f.Required }
    { f with Value = Password newText }


let updateTextField (f:FieldHolder) (newText:string) =
    // { ControlId= f.ControlId; FieldId = f.FieldId; FieldName= f.FieldName; Value= Text newText }
    { f with Value = Text newText }

// let updateDecimalField (f:FieldHolder) (newText:string) (lastVal:decimal) =
//     // { ControlId= f.ControlId; FieldId = f.FieldId; FieldName= f.FieldName; Value= Text newText }
//     match Decimal.TryParse(newText) with   
//         | (true, dec) ->
//             { f with Value = Decimal dec }
//         | (false,_) -> 
//             { f with Value = Decimal lastVal }

let updateFloatField (f:FieldHolder) (newText:string) (lastVal:FloatValue) =
    // { ControlId= f.ControlId; FieldId = f.FieldId; FieldName= f.FieldName; Value= Text newText }
    let noLeadingZeros (str:string) = if str.Length > 1 && str.StartsWith("0") then str.Substring(1) else str
    // printfn "%s %A" newText lastVal
    if newText = "" then
        { f with Value= Float { Display= newText ; Value= 0. } }
    else
        match Double.TryParse(newText) with   
            | (true, d) ->
                { f with Value = Float { Display= noLeadingZeros newText ; Value =  d } }
            | (false,_) -> 
                { f with Value = Float lastVal }

let updateIntField (f:FieldHolder) (newText:string) (lastVal:int) =
    // { ControlId= f.ControlId; FieldId = f.FieldId; FieldName= f.FieldName; Value= Text newText }
    match Int32.TryParse(newText) with   
        | (true, dec) ->
            { f with Value = Int dec }
        | (false,_) -> 
            { f with Value = Int lastVal }

let updateBoolField (f:FieldHolder) bool =
    // { f with Value= Bool ((newText.ToString().ToLower()) = "true" ) }
    { f with Value= Bool bool }

let updateBitStringField (f:FieldHolder) newStr =
    match f.Value with
        | BitString (str,lst) -> 
            { f with Value= BitString (newStr, lst) }
        | _ -> failwith <| sprintf "Unable to update %s with new value %s" f.DisplayName newStr

let updateStringOptionsField (f:FieldHolder) keyStr lst =
    match f.Value with
        // | RadioButtonsString (k,_) -> 
        //     { f with Value= RadioButtonsString ({ k with Key= keyStr },lst) }
        | SelectString (k,_) -> 
            { f with Value= SelectString ( { k with Key= keyStr },lst) }
        | _ -> failwith <| sprintf "Invalid control type for %s with select options" f.DisplayName

let updateDateField (f:FieldHolder) (newText:string)  = 
   { f with Value= DateString newText }

let updateTimeField (f:FieldHolder) (ohours:string option) (omins:string option) (lastVal:string) =
    let validateHours n = if n < 0 || n > 23 then 0 else n
    let validateMins n = if n < 0 || n > 59 then 0 else n
    let optionToNumber o_n = Option.defaultValue 0 o_n
    let tryInt (str:string) =
        match Int32.TryParse(str) with   
            | true, n -> Some n 
            | false, _ -> None
    let strToHours, strToMins = 
        tryInt >> optionToNumber >> validateHours, tryInt >> optionToNumber >> validateMins
    let hours, mins = 
        let time= FieldHolder.valueAsString f
        let arr = time.Split(':')
        arr.[0] |> strToHours, arr.[1] |> strToMins
    let resh, resm =
        match ohours, omins with
            | Some h, _ -> h |> strToHours, mins
            | None, Some m -> hours, m |> strToMins
            | _, _ -> hours, mins
    { f with Value= TimeString <| sprintf "%i:%i" resh resm }

let updateTimeSpanIntField (f:FieldHolder) (ts:IntTimeSpan) =
    let mins = ts.Days * 24 * 60 + ts.Hours * 60 + ts.Minutes
    { f with Value= TimeSpanInt (mins,IntTimeSpan.empty) }


    // // { ControlId= f.ControlId; FieldId = f.FieldId; FieldName= f.FieldName; Value= Text newText }
    // match Int32.TryParse(newText) with   
    //     | (true, dec) ->
    //         { f with Value = Int dec }
    //     | (false,_) -> 
    //         { f with Value = Int lastVal }


let fieldValueStr (fh:FieldHolder) =
    FieldHolder.valueAsString fh 
    // match fh.Value with   
    //     | String str | Text str | Hidden str -> str
    //     | Decimal flt -> (string flt)
    //     | Int i -> string i
    //     | Bool bl -> (string bl)


let validateRequired (fh:FieldHolder) =
    match fh.Behaviour with
        | Default | ReadOnly | Optional -> true
        | Required -> 
            if (fieldValueStr fh).Length > 0 then true
            else false

let validatedForm (fh:FormHolder) =        
    //the required fields are displayed in the controls so we don't need the error messages
    let inputValidations : Result<bool,string> = (fh.Fields |> List.forall validateRequired) |> Ok 
    fh.Validations
        |> List.map (
            fun func -> 
                try func fh 
                with e -> Error <| sprintf "Form Configuration Error - %s" e.Message
        )
        |> List.append [ inputValidations ]
        |> List.fold (
            fun state next -> 
                match state, next with 
                    | Ok b1, Ok b2 -> Ok (b1 && b2)
                    | Ok b, Error err -> Error [ err ]
                    | Error lst, Ok b -> Error lst
                    | Error lst, Error err -> lst @ [ err ] |> Error ) (Ok true)

module Validation =
    let matchingValues controlId1 controlId2 errorMessage formHolder =
        try
            printfn "%s" <| FormHolder.valueAsString formHolder controlId1
            printfn "%s" <| FormHolder.valueAsString formHolder controlId2
            if FormHolder.valueAsString formHolder controlId1 = FormHolder.valueAsString formHolder controlId2 then 
                Ok true
            else Error errorMessage
        with ex -> Error ex.Message
    let minimumLength minLength controlId1 errorMessage formHolder =
        if FormHolder.valueAsString formHolder controlId1 |> String.length >= minLength then 
            Ok true
        else Error errorMessage
    let validGuid controlId errorMessage formHolder = 
        match FormHolder.valueAsString formHolder controlId |> Guid.TryParse with
            | true, guid when guid <> Guid.Empty ->
                Ok true                
            | true, guid -> Error "No request reference found. Please re-send request"
            | false, guid -> Error "Invalid request"
    let validEmail controlId errorMessage formHolder =
        FormHolder.valueAsString formHolder controlId 
            |> (fun str -> str.ToCharArray())
            |> Array.fold (fun st nxt -> if nxt = '@' || nxt = '.' then st + (string nxt) else st) ""
            |> (fun str -> if str.Contains("@.") then Ok true else Error errorMessage)

module Input =
    let fieldStringInput (fh:FieldHolder) (styles:string) (validation:ValidationMessages) (trigger:FieldHolder -> unit) = 
        div [ Class ("form-group" |> addStyle styles) ] [
            label [] [ str fh.DisplayName ]
            input [Id (idOf fh.FieldId); Type "text"; Class "form-control form-control-sm"; 
                    Value ( fh |> fieldValueStr ); 
                    HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                    OnChange (fun e -> trigger (updateStringField fh e.Value ) ) ]
            (if validateRequired fh |> not then
                small [ Class "text-danger" ] [ str validation.Required ] // (sprintf "%s is required" fh.FieldName ) ]
            else
                p [] [] )
        ]

    let passwordStringInput (fh:FieldHolder) (styles:string) (validation:ValidationMessages) (trigger:FieldHolder -> unit) = 
        div [ Class ("form-group" |> addStyle styles) ] [
            label [] [ str fh.DisplayName ]
            input [Id (idOf fh.FieldId + "xxxx"); Type "password"; Class "form-control form-control-sm"; 
                    Value ( fh |> fieldValueStr ); 
                    HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                    OnChange (fun e -> trigger (updatePasswordField fh e.Value ) ) ]
            (if validateRequired fh |> not then
                small [ Class "text-danger" ] [ str validation.Required ] // (sprintf "%s is required" fh.FieldName ) ]
            else
                p [] [] )
        ]

    let fieldMessage (fh:FieldHolder) (styles:string) (validation:ValidationMessages) = 
        div [ Class ("form-group text-secondary" |> addStyle styles) ] [
            label [] [ str fh.DisplayName ]
            p [] [ str (fh |> fieldValueStr) ]
        ]
    let fieldTextInput (fh:FieldHolder) (styles:string) (validation:ValidationMessages) (trigger:FieldHolder -> unit) = 
        div [ Class ("form-group" |> addStyle styles) ] [
            label [] [ str fh.DisplayName ]
            // textarea [] []
            textarea [ Id (idOf fh.FieldId); Class "form-control form-control-sm"; 
                    Value ( fh |> fieldValueStr ); 
                    Rows 10;
                    OnChange (fun e -> trigger (updateTextField fh (string e.Value) ) ) ] [ fh |> fieldValueStr |> str ]
            (if validateRequired fh |> not then
                small [ Class "text-muted" ] [ str validation.Required ] // (sprintf "%s is required" fh.FieldName ) ]
            else
                p [] [] )
        ]

    let fieldHiddenString (fh:FieldHolder) = 
        div [] [] //input [ Id (idOf fh.FieldId); Type "hidden"; Class "form-control form-control-sm"; Value ( fh |> fieldValueStr ) ] 

    // let fieldDecimalInput (fh:FieldHolder) (styles:string) (validation:ValidationMessages) (trigger:FieldHolder -> unit) = 
    //     div [ Class ("form-group" |> addStyle styles) ] [
    //         label [] [ str fh.DisplayName ]
    //         input [Id (idOf fh.FieldId); Type "number"; Class "form-control form-control-sm"; 
    //                 Value ( fh |> fieldValueStr ); 
    //                 HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);                    
    //                 OnChange (fun e -> trigger (updateDecimalField fh e.Value (FieldHolder.valueAsDecimal fh) ) ) ]
    //         (if validatedInput fh |> not then
    //             small [ Class "text-danger" ] [ str validation.Required ] // (sprintf "%s is required" fh.FieldName ) ]
    //         else
    //             p [] [] )
    //     ]

    let fieldFloatInput (fh:FieldHolder) (styles:string) (validation:ValidationMessages) (trigger:FieldHolder -> unit) = 
        let readFloatHolder = function | Float tup -> tup | _ -> FloatValue.zero
        div [ Class ("form-group" |> addStyle styles) ] [
            label [] [ str fh.DisplayName ]
            input [Id (idOf fh.FieldId); Type "number"; Class "form-control form-control-sm"; 
                    Value ( fh |> fieldValueStr ); 
                    HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);                    
                    OnChange (fun e -> trigger (updateFloatField fh e.Value (readFloatHolder fh.Value) ) ) ]
            (if validateRequired fh |> not then
                small [ Class "text-danger" ] [ str validation.Required ] // (sprintf "%s is required" fh.FieldName ) ]
            else
                p [] [] )
        ]

    let fieldIntInput (fh:FieldHolder) (styles:string) (validation:ValidationMessages) (trigger:FieldHolder -> unit) = 
        let numbersOnly str = 
            let allowed = [ '-' ; '0' ; '1' ; '2' ; '3' ; '4' ; '5' ; '6' ; '7' ; '8' ; '9' ]
            [| for c in str do
                    if allowed |> List.tryFind (fun x -> x = c) |> Option.isSome then yield c
            |]
                |> (fun x -> (new String(x)) )
        div [ Class ("form-group" |> addStyle styles) ] [
            label [] [ str fh.DisplayName ]
            input [ Id (idOf fh.FieldId); Type "number"; Class "form-control form-control-sm"; 
                    Value ( fh |> fieldValueStr )
                    HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                    OnChange (fun e -> trigger (updateIntField fh e.Value (FieldHolder.valueAsInt fh) ) ) ]
            (if validateRequired fh |> not then
                small [ Class "text-danger" ] [ str validation.Required ] // (sprintf "%s is required" fh.FieldName ) ]
            else
                p [] [] )
        ]

    let fieldBoolInput (fh:FieldHolder) (styles:string) (validation:ValidationMessages) (trigger:FieldHolder -> unit) = 
        let bval = (FieldHolder.valueAsBool fh)
        let checkEvent = (fun _ -> trigger (updateBoolField fh (not bval)) )
            // div [ Class "form-check" ] [
            //     input [ Id (idOf fh.FieldId); Type "checkbox"; Class "form-check-input" 
            //             Checked ( fh |> FieldHolder.valueAsBool  )
            //             HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly)
            //             OnChange (fun e -> trigger (updateStringField fh e.Value ) ) ]
            //     label [ Class "form-check-label" ] [ str fh.DisplayName ]
            // ]
        div [ Class <| addStyle styles "form-group form-check" ; OnClick checkEvent ] [
            div [ Class "d-inline" ; Style [ PaddingRight "20px" ] ] [ str "" ]
            input [ Id fh.ControlId ; Type "checkbox"; Class "form-check-input form-control-sm"; 
                    Checked bval; 
                    OnChange checkEvent ]
            // , label [for (id_ name) ] [text name]
            label [ HtmlFor fh.ControlId ] [ str fh.DisplayName ]
            (if validateRequired fh |> not then
                small [ Class "text-danger" ] [ str validation.Required ] // (sprintf "%s is required" fh.FieldName ) ]
            else
                p [] [] )
        ]


// <div class="custom-control custom-switch">
//   <input type="checkbox" class="custom-control-input" id="customSwitch1">
//   <label class="custom-control-label" for="customSwitch1">Toggle this switch element</label>
// </div>
    let fieldBitStringInput (fh:FieldHolder) (bitString:string*string list) (styles:string) (validation:ValidationMessages) (trigger:FieldHolder -> unit) =
        let isChecked index = match fst bitString |> (fun s -> s.ToCharArray() ) |> Array.tryItem index with
                                            | Some c -> c = '1'
                                            | None -> false 
        let displayName index = snd bitString |> List.tryItem index |> Option.defaultValue ""
        let controlid fh index = sprintf "%s%i" fh.ControlId index 
        let checkEvent index = ( fun _ -> (fst bitString).ToCharArray()
                                            |> Array.mapi (fun i x ->   if i = index then
                                                                            if isChecked index then '0' else '1'
                                                                        else x )
                                            |> (fun x -> new String(x) )
                                            |> updateBitStringField fh 
                                            |> trigger )                                           
        let switch index name = 
            let cid = (idOf fh.FieldId) + (sprintf "%i" index )
            div [ Class "form-check" ] [
                // div [ Class "d-inline"; Style [ PaddingRight "20px" ] ] [ str "" ]
                input [ Id cid  ; Type "checkbox"; Class "form-check-input form-control-sm"; 
                        Checked <| isChecked index; 
                        OnChange <| checkEvent index ]
                // , label [for (id_ name) ] [text name]
                label [ OnClick <| checkEvent index ; HtmlFor cid ] [ str <| displayName index ]
                // (if validatedInput fh |> not then
                //     small [ Class "text-danger" ] [ str validation.Required ] // (sprintf "%s is required" fh.FieldName ) ]
                // else
                //     p [] [] )
            ]
        div [ Class <| addStyle styles "form-group" ] [
            label [] [ str fh.DisplayName ]
            div [] (                
                // (snd bitString) |> List.mapi (fun i x -> li [ Class "list-group-item" ] [ switch i x ] )
                (snd bitString) |> List.mapi (fun i x -> switch i x )                
            )
        ]
 
    let selectManyStrings (fh:FieldHolder) (selections:string*SelectOptionString list) (styles:string) (validation:ValidationMessages) (trigger:FieldHolder -> unit) =
        let selected= fst selections |> (fun str -> str.Split([| ";" |], StringSplitOptions.RemoveEmptyEntries)) |> Array.toList
        let isChecked key = selected |> List.exists (fun s -> s = key) 
        // let displayName index = snd selections |> List.tryItem index |> Option.defaultValue ""
        let controlid fh index = sprintf "%s%i" fh.ControlId index 
        let checkEvent key = ( fun _ -> let filtered = selected |> List.filter (fun x -> x <> key)
                                        (if selected.Length = filtered.Length then
                                            selected |> List.append [ key ]
                                        else filtered)
                                            |> String.concat ";"
                                            |> (fun selected -> 
                                                    { fh with Value = SelectManyStrings (selected,snd selections) } )
                                            |> trigger )                                           

        let switch opt = 
            let cid = (idOf fh.FieldId) + (sprintf "%s" opt.Key )
            div [   Class "form-check" 
                    OnClick <| checkEvent opt.Key 
            ] [                               
                input [ Id cid
                        Type "checkbox"
                        Class "form-check-input form-control-sm" 
                        DefaultChecked <| isChecked opt.Key 
                        // OnChange <| checkEvent opt.Key ]
                ]
                label [     HtmlFor cid 
                ] [ str opt.Value ]
            ]
        div [ Class <| addStyle styles "form-group" ] [
            label [] [ str fh.DisplayName ]
            div [] (                
                // (snd bitString) |> List.mapi (fun i x -> li [ Class "list-group-item" ] [ switch i x ] )
                (snd selections) |> List.map switch                
            )
        ]

    let buttonsManyStrings (fh:FieldHolder) (selections:string*SelectOptionString list) (styles:string) (validation:ValidationMessages) (trigger:FieldHolder -> unit) =
        let alloptions = snd selections
        let selected= fst selections |> (fun str -> str.Split([| ";" |], StringSplitOptions.RemoveEmptyEntries)) |> Array.toList
        let isChecked key = selected |> List.exists (fun s -> s = key) 
        // let displayName index = snd selections |> List.tryItem index |> Option.defaultValue ""
        let controlid fh index = sprintf "%s%i" fh.ControlId index 
        let checkEvent key = ( fun _ -> let filtered = selected |> List.filter (fun x -> x <> key)
                                        (if selected.Length = filtered.Length then
                                            selected |> List.append [ key ]
                                        else filtered)
                                            |> String.concat ";"
                                            |> (fun selected -> 
                                                    { fh with Value = SelectManyStrings (selected,snd selections) } )
                                            |> trigger )                                           

        let switch i opt = 
            let id i = sprintf "%s%i" fh.ControlId i 
            button [    Class <| "mr-1 mb-1 btn btn-sm " + (if (isChecked opt.Key) then "btn-primary" else "btn-outline-primary")
                        Type "button"
                        Id <| id i
                        Value opt.Key
                        OnClick (checkEvent opt.Key) 
            ] [
                str opt.Value
            ]
            // let cid = (idOf fh.FieldId) + (sprintf "%s" opt.Key )
            // div [   Class "form-check" 
            //         OnClick <| checkEvent opt.Key 
            // ] [                               
            //     input [ Id cid
            //             Type "checkbox"
            //             Class "form-check-input form-control-sm" 
            //             DefaultChecked <| isChecked opt.Key 
            //             // OnChange <| checkEvent opt.Key ]
            //     ]
            //     label [     HtmlFor cid 
            //     ] [ str opt.Value ]
            // ]
        div [ Class <| addStyle styles "form-group" ] [
            label [] [ str fh.DisplayName ]
            div [] (                
                // (snd bitString) |> List.mapi (fun i x -> li [ Class "list-group-item" ] [ switch i x ] )
                alloptions |> List.mapi switch                
            )
        ]

    let dateStringInput (fh:FieldHolder) (styles:string) (validation:ValidationMessages) (trigger:FieldHolder -> unit) =
        div [ Class ("form-group" |> addStyle styles) ] [
            label [] [ str fh.DisplayName ]
            input [ Id (idOf fh.FieldId); Type "date"; Class "form-control form-control-sm"; 
                    Value ( fh |> fieldValueStr )
                    HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                    OnChange (fun e -> trigger (updateDateField fh e.Value ) ) ]
            (if validateRequired fh |> not then
                small [ Class "text-danger" ] [ str validation.Required ] // (sprintf "%s is required" fh.FieldName ) ]
            else
                p [] [] )
        ]

    let timeStringInput (fh:FieldHolder) (timestr:string) (styles:string) (validation:ValidationMessages) (trigger:FieldHolder -> unit) =
        let numbersOnly str = 
            let allowed = [ '0' ; '1' ; '2' ; '3' ; '4' ; '5' ; '6' ; '7' ; '8' ; '9' ]
            [| for c in str do
                    if allowed |> List.tryFind (fun x -> x = c) |> Option.isSome then yield c
            |]
                |> (fun x -> (new String(x)) )
        let hours, mins = 
            let time= FieldHolder.valueAsString fh
            let arr = time.Split(':')
            arr.[0], arr.[1]
        div [ Class ("form-group" |> addStyle styles) ] [
            label [] [ str fh.DisplayName ]
            //hours
            div [ Class "form-row" ] [
                input [ Id (idOf fh.FieldId + "h"); Type "text"; 
                        Class "form-control form-control-sm w-25"; 
                        Value hours 
                        HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                        OnChange (fun e -> trigger (updateTimeField fh (Some e.Value) None timestr  ) ) ]
                p [ Class "ml-1 mr-1" ] [ str ":" ]
                //minutes
                input [ Id (idOf fh.FieldId + "m"); Type "text"; 
                        Class "form-control form-control-sm w-25"; 
                        Value mins
                        HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                        OnChange (fun e -> trigger (updateTimeField fh None (Some e.Value) timestr ) ) ]
            ]
            div [ Class "form-row" ] [
                small [ Class "text-secondary w-25" ] [ str "hours" ]
                p [ Class "ml-1 mr-1" ] [ str ":" ]
                small [ Class "text-secondary w-25" ] [ str "minutes" ]
                // input [ Id (idOf fh.FieldId + "h"); Type "text"; 
                //         Class "form-control form-control-sm w-25"; 
                //         Value hours 
                //         HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                //         OnChange (fun e -> trigger (updateTimeField fh (Some e.Value) None timestr  ) ) ]
                // p [ Class "ml-1 mr-1" ] [ str ":" ]
                //minutes
                // input [ Id (idOf fh.FieldId + "m"); Type "text"; 
                //         Class "form-control form-control-sm w-25"; 
                //         Value mins
                //         HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                //         OnChange (fun e -> trigger (updateTimeField fh None (Some e.Value) timestr ) ) ]
            ]
            (if validateRequired fh |> not then
                small [ Class "text-danger" ] [ str validation.Required ] // (sprintf "%s is required" fh.FieldName ) ]
            else
                p [] [] )
        ]

// <div class="form-check">
//   <input class="form-check-input" type="radio" name="exampleRadios" id="exampleRadios1" value="option1" checked>
//   <label class="form-check-label" for="exampleRadios1">
//     Default radio
//   </label>
// </div>
// <div class="form-check">
//   <input class="form-check-input" type="radio" name="exampleRadios" id="exampleRadios2" value="option2">
//   <label class="form-check-label" for="exampleRadios2">
//     Second default radio
//   </label>
// </div>

    // let radioButtonsInput<'a when 'a : equality> (fh:FieldHolder) (options:'a*SelectOption<'a> list) (styles:string) 
    let buttonsStringInput (fh:FieldHolder) (options:OptionKey*SelectOptionString list) (styles:string) 
                                    (validation:ValidationMessages) (trigger:FieldHolder -> unit) =
        let alloptions = snd options
        let selected = fst options
        let withMatches =   alloptions
                                |> List.mapi (fun i x -> i, x.Key = selected.Key, x)
        //let third (_, _, c) = c
        let radio (i,isSelected,(option:SelectOptionString)) = 
            let id i = sprintf "%s%i" fh.ControlId i 
            button [    Class <| "mr-1 mb-1 btn btn-sm " + (if isSelected then "btn-primary" else "btn-outline-primary")
                        Type "button"
                        Id <| id i
                        Value option.Key
                        OnClick (fun e -> trigger (updateStringOptionsField fh e.Value alloptions ) ) 
            ] [
                str option.Value
            ]
            // div [ Class "form-check" ] [
            //     input [ Type "radio" ; Id <| id i ;
            //                 Class "form-check-input" ;
            //                 HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly) ;
            //                 Value option.Key ;
            //                 Checked isSelected ;
            //                 OnChange (fun e -> trigger (updateStringOptionsField fh e.Value (snd options) ) ) ]
            //     label [ Class "form-check-label" ; HtmlFor (id i) ] [ str option.Value ] 
            // ]
        div [ Class ("form-group" |> addStyle styles) ] (
            div [ Class "row" ] (
                withMatches 
                    |> List.map radio
            )
                |> List.singleton
                |> List.append [ label [] [ str fh.DisplayName ] ]
        )

    let radioButtonsStringInput (fh:FieldHolder) (options:OptionKey*SelectOptionString list) (styles:string) 
                                    (validation:ValidationMessages) (trigger:FieldHolder -> unit) =
        let alloptions = snd options
        let selected = fst options
        let withMatches =   alloptions
                                |> List.mapi (fun i x -> i, x.Key = selected.Key, x)
        let third (_, _, c) = c
        let radio (i,isSelected,(option:SelectOptionString)) = 
            let id i = sprintf "%s%i" fh.ControlId i 
            div [ Class "form-check" ] [
                input [ Type "radio" ; Id <| id i ;
                            Class "form-check-input" ;
                            HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly) ;
                            Value option.Key ;
                            Checked isSelected ;
                            OnChange (fun e -> trigger (updateStringOptionsField fh e.Value (snd options) ) ) ]
                label [ Class "form-check-label" ; HtmlFor (id i) ] [ str option.Value ] 
            ]
        div [ Class ("form-group" |> addStyle styles) ] (            
            withMatches 
                |> List.map radio
                |> List.append [ label [] [ str fh.DisplayName ] ]
        )

    let selectStringInput (fh:FieldHolder) (options:OptionKey*SelectOptionString list) (styles:string) 
                                    (validation:ValidationMessages) (trigger:FieldHolder -> unit) =
        //printfn "%A" options
        let alloptions = snd options
        let selected = fst options
        let emptyOption = { Key= "0" ; Value = "Select One ..." } 
        let withMatches =   alloptions
                                |> List.append [ emptyOption ]
                                |> List.mapi (fun i x -> i, x.Key = selected.Key, x)                                   
        // let selectedKey optstr = snd options 
        //                             |> List.tryFind (fun x -> x.Value = optstr) 
        //                             |> Option.defaultValue emptyOption
        //                             |> (fun x -> x.Key)

        let third (_, _, c) = c
        let showOption (i,selected,(o:SelectOptionString)) = 
            // let id i = sprintf "%s%i" fh.ControlId i 
            option [    //Selected selected
                        Value o.Key
            ] [ str o.Value ]
        div [ Class ("form-group" |> addStyle styles) ] [
            label [ Class "form-check-label" ; HtmlFor fh.ControlId ] [ str fh.DisplayName ] 
            select [    Id fh.ControlId
                        Class "form-control"              
                        OnChange (fun e -> 
                                    //printfn "%A" e.Value
                                    //printfn "%A" <| (updateStringOptionsField fh e.Value (snd options) )
                                    trigger (updateStringOptionsField fh e.Value (snd options) ) ) 
                        Value (selected.Key) //(fst options |> selectedKey)
                ] (
                withMatches 
                    |> List.map showOption

                )
        ]

    let timeSpanInt (fh:FieldHolder) (mins:int) (styles:string) (validation:ValidationMessages) (trigger:FieldHolder -> unit) =
        let numbersOnly str = 
            let allowed = [ '0' ; '1' ; '2' ; '3' ; '4' ; '5' ; '6' ; '7' ; '8' ; '9' ]
            [| for c in str do
                    if allowed |> List.tryFind (fun x -> x = c) |> Option.isSome then yield c
            |]
                |> (fun x -> (new String(x)) )
                |> (fun x -> match Int32.TryParse(x) with
                                | true, i -> i
                                | _, _ -> 0 )
        // let hours, mins = 
        //     let time= FieldHolder.valueAsString fh
        //     let arr = time.Split(':')
        //     arr.[0], arr.[1]
        let timeSpan = 
            let fmins = Convert.ToDouble(mins)    
            {   Days= fmins / (24. * 60.) |> int
                //Hours= fmins % 24. |> (fun x -> Math.Floor(x/60.) ) |> int
                Hours= Math.Floor(fmins/60.) |> (fun x -> x % 24.) |> int
                Minutes= fmins % 60. |> int
            } 
        div [ Class ("form-group" |> addStyle styles) ] [
            label [] [ str fh.DisplayName ]
            //hours
            div [ Class "form-row" ] [ 
                input [ Id (idOf fh.FieldId + "d"); Type "text"; 
                        Class "form-control form-control-sm w-25"; 
                        Value timeSpan.Days //<| string timeSpan.Days
                        HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                        OnChange (fun e -> trigger (updateTimeSpanIntField fh { Days= e.Value |> numbersOnly ; Hours= timeSpan.Hours ; Minutes= timeSpan.Minutes } ) ) ]
                p [ Class "ml-1 mr-1" ] [ str ":" ]
                input [ Id (idOf fh.FieldId + "h"); Type "text"; 
                        Class "form-control form-control-sm w-25"; 
                        Value timeSpan.Hours //<| string timeSpan.Hours 
                        HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                        OnChange (fun e -> trigger (updateTimeSpanIntField fh { Days= timeSpan.Days ; Hours= e.Value |> numbersOnly ; Minutes= timeSpan.Minutes } ) ) ]
                p [ Class "ml-1 mr-1" ] [ str ":" ]
                //minutes
                input [ Id (idOf fh.FieldId + "m"); Type "text"; 
                        Class "form-control form-control-sm w-25"; 
                        Value timeSpan.Minutes //<| string timeSpan.Minutes
                        HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                        OnChange (fun e -> trigger (updateTimeSpanIntField fh { Days= timeSpan.Days ; Hours= timeSpan.Hours; Minutes= e.Value |> numbersOnly } ) ) ]
            ]
            div [ Class "form-row" ] [
                small [ Class "text-secondary w-25" ] [ str "days" ]
                p [ Class "ml-1 mr-1" ] [ str ":" ]
                small [ Class "text-secondary w-25" ] [ str "hours" ]
                p [ Class "ml-1 mr-1" ] [ str ":" ]
                small [ Class "text-secondary w-25" ] [ str "minutes" ]
                // input [ Id (idOf fh.FieldId + "h"); Type "text"; 
                //         Class "form-control form-control-sm w-25"; 
                //         Value hours 
                //         HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                //         OnChange (fun e -> trigger (updateTimeField fh (Some e.Value) None timestr  ) ) ]
                // p [ Class "ml-1 mr-1" ] [ str ":" ]
                //minutes
                // input [ Id (idOf fh.FieldId + "m"); Type "text"; 
                //         Class "form-control form-control-sm w-25"; 
                //         Value mins
                //         HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                //         OnChange (fun e -> trigger (updateTimeField fh None (Some e.Value) timestr ) ) ]
            ]

            (if validateRequired fh |> not then
                small [ Class "text-danger" ] [ str validation.Required ] // (sprintf "%s is required" fh.FieldName ) ]
            else
                p [] [] )
        ]


// let styledCheckBox name value styles (trigger:bool -> unit) =
//     div [ Class <| addStyle styles "form-group form-check" ] [
//         div [ Class "d-inline"; Style [ PaddingRight "20px" ] ] [ str "" ]
//         input [ Id (idOf name) ; Type "checkbox"; Class "form-check-input form-control-sm"; 
//                 Checked value; 
//                 OnChange (fun _ -> trigger (not value) ) ]
//         // , label [for (id_ name) ] [text name]
//         label [] [ str name ]
//     ]

let getInput (field:FieldHolder) colspan (validation:ValidationMessages) dispatch =
    match field.Value with
        | String str -> Input.fieldStringInput field colspan validation (ValueChanged >> dispatch)
        | Message str -> Input.fieldMessage field colspan validation
        | Text str -> Input.fieldTextInput field colspan validation (ValueChanged >> dispatch)
        | Password str -> Input.passwordStringInput field colspan validation (ValueChanged >> dispatch)
        | Hidden str -> Input.fieldHiddenString field
        // | Date str -> 
        // | Decimal flt -> Input.fieldDecimalInput field "col-sm-6" validation (ValueChanged >> dispatch)
        // | Double flt 
        | Float flt -> Input.fieldFloatInput field colspan validation (ValueChanged >> dispatch)
        | Int i -> Input.fieldIntInput field colspan validation (ValueChanged >> dispatch)
        | Bool b -> Input.fieldBoolInput field colspan validation (ValueChanged >> dispatch)
        | BitString (str,lst) -> Input.fieldBitStringInput field (str,lst) colspan validation (ValueChanged >> dispatch)
        | DateString str -> Input.dateStringInput field colspan validation (ValueChanged >> dispatch)
        | TimeString str -> Input.timeStringInput field str colspan validation (ValueChanged >> dispatch)
        // | RadioButtonsString (sel,options) -> Input.radioButtonsStringInput field (sel,options) colspan validation (ValueChanged >> dispatch)
        | SelectString (sel,options) -> 
            match field.Layout with 
                | Layout.RadioButtons ->
                    Input.radioButtonsStringInput field (sel,options) colspan validation (ValueChanged >> dispatch)
                | Layout.Buttons -> 
                    Input.buttonsStringInput field (sel,options) colspan validation (ValueChanged >> dispatch)
                | _ ->
                    Input.selectStringInput field (sel,options) colspan validation (ValueChanged >> dispatch)
        | SelectManyStrings (sel,options) -> 
            match field.Layout with 
                | Layout.Buttons -> 
                    Input.buttonsManyStrings field (sel,options) colspan validation (ValueChanged >> dispatch)                    
                | _ ->
                    Input.selectManyStrings field (sel,options) colspan validation (ValueChanged >> dispatch)
        | TimeSpanInt (i,_) -> Input.timeSpanInt field i colspan validation (ValueChanged >> dispatch)

module View=
    let formWithColspan (form:FormHolder) colspan dispatch = 
        inFormWithCaption form.Caption [
            div [ Class "d-block"; Style [ PaddingBottom "10px" ] ] [
            ]
            // formSubCaption "Item Information"
            div [ Class "form-row" ] (
                form.Fields
                    |> List.map (fun x -> getInput x colspan form.ValidationMessages dispatch)
            )
            div [] (
                match validatedForm form with
                    | Ok b -> []
                    | Error errs -> errs |> List.map (fun err -> p [ Class "text-danger" ] [ str err ] )
            )
        ]

    let form (form:FormHolder) dispatch = 
        formWithColspan form "col-sm-6" dispatch
        // inFormWithCaption form.Caption [
        //     div [ Class "d-block"; Style [ PaddingBottom "10px" ] ] [
        //     ]
        //     // formSubCaption "Item Information"
        //     div [ Class "form-row" ] (
        //         form.Fields
        //             |> List.map (fun x -> getInput x "col-sm-6" form.ValidationMessages dispatch)
        //     )
        // ]

    let formDisabled (form:FormHolder) dispatch =
        inFormWithCaption form.Caption [
            div [ Class "d-block"; Style [ PaddingBottom "40px" ] ] [
            ]
            // fieldset [ Disabled true ] [
                // formSubCaption "Item Information"
            div [ Class "form-row" ] (
                form.Fields
                    |> List.map (fun x -> { x with Behaviour= ReadOnly } )
                    |> List.map (fun x -> getInput x "col-sm-6" form.ValidationMessages dispatch)
            )
            // ]
        ]

    let borderlessWithColspan (form:FormHolder) colspan dispatch = 
        form.Fields
            |> List.map (fun x -> getInput x colspan form.ValidationMessages dispatch)
            |> inForm

    let borderless (form:FormHolder) dispatch =
        borderlessWithColspan form "col-sm-6" dispatch 

