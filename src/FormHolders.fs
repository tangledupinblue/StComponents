module Components.FormHolders

open System
open Fable.Core
open Elmish.React
open Fable.React
open Fable.React.Props
open Fetch
open Thoth.Json

//open Components.FormControls


let idOf (name:string) = name.Replace(" ","_")

let addStyle extend onto = 
    let moreStyles styles = if String.length styles > 0 then " " + styles else ""
    onto + moreStyles extend



// NB - be careful with decimal types
// Notes from Thoth.Json
// ### Decoding int64, decimal or bigint
//Coders for `int64`, `decimal` or `bigint` won't be automatically generated by default. 
//If they were, the bundle size would increase significantly even if you don't intend to use these types.

// type SelectOption<'a> = {
//     Key: 'a
//     Value: string
// }
//     with 
//         static member empty = { Key= Unchecked.defaultof<'a> ; Value= "" }
//         static member findInList lst k = 
//                 List.tryFind (fun x -> x.Key = k) lst 
//                 |> Option.defaultValue SelectOption.empty
//                 |> (fun x -> x.Key)

// type SelectOptionString = SelectOption<string>

//NB - not all layouts supported for all types ; if not supported will switch to Default
// type Layout =
//     | Default = 0
//     | DropDown = 1
//     | Buttons = 2
//     | RadioButtons = 3
//     | Checklist = 4
//     | Stars = 5

type SelectLayout = 
    | DropDown
    | Buttons
    | RadioButtons

type SelectManyLayout =
    | Checklist
    | Buttons

type TimeLayout = 
    | HourMinute
    | HourMinuteSecond

type Layout = 
    | Default
    | Select of SelectLayout
    | SelectMany of SelectManyLayout
    | Time of TimeLayout

// type KeyType = 
//     | StringKey
//     | IntKey
//     // | GuidKey

// type OptionKey = {
//     Key: string
//     KeyType: KeyType
// }
//     with 
//         static member string str = { Key= str ; KeyType= StringKey } 
//         static member int str = { Key= str ; KeyType= IntKey } 
//         //static member guid str = { Key= str ; KeyType= GuidKey } 

type SelectKey =
    | StringKey of string
    | IntKey of int
    | GuidKey of Guid
    with static member asString = function | IntKey i -> sprintf "%i" i | StringKey str -> str | GuidKey g -> g.ToString()

type SelectOptionString = {
    Key: string
    Value: string
}
    with static member listFromStrings strings= strings |> List.map (fun s -> { Key= s ; Value= s })

type IntTimeSpan = {
    Days: int
    Hours: int
    Minutes: int
}
    with 
        static member empty = { Days= 0 ; Hours= 0 ; Minutes= 0 }
        static member isEmpty ts = ts.Days = 0 && ts.Hours = 0 && ts.Minutes = 0


// type SelectOptionString = {
//     Key: string
//     Value: string
// }
//     with 
//         static member empty = { Key= "" ; Value= "" }
//         static member findInList (lst:SelectOptionString list) k = 
//                 List.tryFind (fun x -> x = k) lst 
//                 |> Option.defaultValue SelectOptionString.empty
//                 |> (fun x -> x.Key)

// type SelectOptionInt = {
//     Key: int
//     Value: string
// }

//TODO - implement this as a separate namespace that uses the ValueHolders
// type FormQuestion = {
//     FieldId: string
//     DisplayText: string
//     ResponseFloat: float option
//     ResponseString: string option
//     ResponseOptions: string list option
// }

// module Convert = 
//     let stringToInt context str =
//         match Int32.TryParse str with
//             | true, i -> i
//             | _ ->  failwith <| sprintf "Expecting a number value for %s but got %s instead" context str


type FloatValue = {
    Display: string
    Value: float
}
    with 
        static member fromFloat flt = 
                            {   Display= if flt = 0. then "0" else sprintf "%.2f" flt
                                Value= flt }
        static member zero = { Display= "0" ; Value= 0. }

type ValueHolder =
    | String of string
    | Text of string
    | Message of string   
    | Password of string 
    // | Select of string*string
    | SelectOption of SelectKey*SelectOptionString list 
    // | RadioButtonsString of OptionKey*SelectOptionString list
    | SelectManyOptions of string*SelectOptionString list
    | BitString of string*string list    
    | DateString of string
    | DateTimeString of string
    | TimeString of string
    | Hidden of ValueHolder //string
    //| Decimal of decimal //this can sometimes cause problems with Thoth.Json - 
    | Float of FloatValue //(string*float)
    //| Double of double
    | Int of int
    | Bool of bool
    | TimeSpanInt of int*IntTimeSpan  //time span in minutes    
    | HtmlPreview of string
    with
        static member float flt = FloatValue.fromFloat flt |> Float
        static member intFromStrings sel (options:(int*string) list) = 
            options
                |> List.map (fun (k,v) -> { Key = string k ; Value = v })
                |> (fun opts -> IntKey sel, opts )
                |> SelectOption           
        static member stringFromStrings sel (options:(string*string) list) =
            options
                |> List.map (fun (k,v) -> { Key = string k ; Value = v })
                |> (fun opts -> StringKey sel, opts )
                |> SelectOption           
        static member stringsFromStrings sel (options:(string*string) list) =
            options
                |> List.map (fun (k,v) -> { Key = string k ; Value = v })
                |> (fun opts -> sel, opts )
                |> SelectManyOptions       
        static member equalTypes vh1 vh2 =
                        let typeName vh = vh |> string |> (fun str -> str.Split(' ')) |> Array.tryHead
                        match typeName vh1, typeName vh2 with
                            | Some v1, Some v2 when v1 = v2 -> true                                
                            | _, _ -> false
            
                 
type InputBehaviour = 
    | Default
    | Optional
    | Required
    | ReadOnly

type HelpControl =
    | HelpIcon
    | HelpButton

type FieldHelper = 
    | NoHelp
    | Help of (HelpControl*Helpers.HelpContentType)
    
let splitCamelCase (str:string) = 
    str.ToCharArray()     
        |> Array.fold (fun s c -> match Char.IsUpper c, fst s |> String.length, snd s |> String.length with
                                    | _, 0, 0 -> "", sprintf "%c" (c |> Char.ToUpper)
                                    | true, _, _ -> fst s, sprintf "%s%c" (snd s) c                 //(snd s) + (sprintf "%c" c)  
                                    | false, 0, _ -> sprintf "%s%s%c" (fst s) (snd s) c, ""         //(fst s) + (snd s) + (sprintf "%c" c), ""
                                    | false, _, 0 -> sprintf "%s%c" (fst s) c, ""                   //(fst s) + (sprintf "%c" c), "" 
                                    | false, _, _ -> sprintf "%s %s%c" (fst s) (snd s) c, ""  )     //(fst s) + " " + (snd s) + (sprintf "%c" c), "" )
                        ("","")
        |> (fun (x,y) -> x + (if String.length y > 0 then " " + y else "" ) )


type FieldHolder = {
    ControlId: string           //unique id for control - use in instances where there is more than one of the same form
    FieldId: string             //name of the field - this will be what is used when converted to json
    DisplayName: string         //what the user sees
    Value: ValueHolder   
    Behaviour: InputBehaviour
    Layout: Layout
    Help: FieldHelper
}
    with 
        static member empty = { ControlId=""; FieldId=""; DisplayName=""; Value= String ""; Behaviour= Default ; Layout= Layout.Default; Help= NoHelp  }
        static member create name value = 
                { ControlId= name; FieldId= name; DisplayName= splitCamelCase name; 
                Value= value; Behaviour= Required ; Layout= Layout.Default; Help= NoHelp   }
        static member createId fieldId display value = 
                { ControlId= fieldId; FieldId= fieldId; DisplayName= splitCamelCase display; 
                Value= value; Behaviour= Required ; Layout= Layout.Default; Help= NoHelp   }        
        static member createBehaviour name value behaviour = 
                { ControlId= name; FieldId= name ; DisplayName= splitCamelCase name; 
                Value= value; Behaviour= behaviour ; Layout= Layout.Default; Help= NoHelp   }
        static member createHiddenString name strValue =    {   ControlId= name; FieldId= name; DisplayName= ""; 
                                                                Value= String strValue |> Hidden; Behaviour= Default ;
                                                                Layout= Layout.Default; Help= NoHelp  }
        static member createHiddenInt name intValue =       {   ControlId= name; FieldId= name; DisplayName= ""; 
                                                                Value= Int intValue |> Hidden; Behaviour= Default ;
                                                                Layout= Layout.Default; Help= NoHelp  }
        static member createHiddenFloat name fltValue =     {   ControlId= name; FieldId= name; DisplayName= "";
                                                                Value= ValueHolder.float fltValue |> Hidden ; Behaviour= Default ;
                                                                Layout= Layout.Default; Help= NoHelp  }
        static member createHiddenBool name blValue =       {   ControlId= name; FieldId= name; DisplayName= "";
                                                                Value= Bool blValue |> Hidden ; Behaviour= Default ;
                                                                Layout= Layout.Default; Help= NoHelp  }

        static member createMessage msg =                   {   ControlId= "message"; FieldId= msg; DisplayName= "";
                                                                Value= Message msg ; Behaviour= Default ;
                                                                Layout= Layout.Default; Help= NoHelp  }
        static member setBehaviour behaviour fh = { fh with Behaviour= behaviour }
        static member setLayout layout fh = { fh with Layout= layout }

        static member setHelp helper fh = { fh with Help= helper }

        static member valueAsString fieldholder =
            let rec getString fh=
                match fh with 
                    | String s | Text s | Message s | Password s 
                    | DateString s | DateTimeString s | TimeString s 
                    | HtmlPreview s -> s
                    | BitString (s,_)  
                    | SelectManyOptions (s,_) -> s
                    //| SelectOption (s,_) -> s |> function | IntKey i -> sprintf "%i" i | StringKey str -> str
                    | SelectOption (sk,_) -> sk |> SelectKey.asString
                    //| Decimal d -> sprintf "%.2f" d
                    // | Double d 
                    | Float d -> d.Display //sprintf "%.2f" (snd d)
                    | Int i -> i.ToString()
                    | TimeSpanInt (i,_) -> i.ToString()
                    | Bool b -> b.ToString()
                    | Hidden vh -> getString vh
            getString fieldholder.Value

        static member valueAsBool fieldholder = 
            let rec getBool fh =
                match fh with 
                    | String s | Message s | Text s -> 
                        if (s.ToLower()) = "true" then true
                        else if (s.ToLower()) = "false" then false
                        else failwith <| sprintf "Expecting a boolean value for %s but got %s instead" fieldholder.DisplayName s
                    //| Decimal d -> failwith <| sprintf "Expecting a boolean value for %s but got %f instead" fieldholder.DisplayName d
                    // | Double d 
                    | Password s -> failwith <| sprintf "Expecting a boolean value for %s but got %s instead" fieldholder.DisplayName "password"
                    | Float d -> failwith <| sprintf "Expecting a boolean value for %s but got %f instead" fieldholder.DisplayName (d.Value)
                    | Int i -> failwith <| sprintf "Expecting a boolean value for %s but got %i instead" fieldholder.DisplayName i
                    | Bool b -> b
                    | Hidden s -> getBool s  
                    | _ -> failwith <| sprintf "Cannot convert value for %s of %A to %s" fieldholder.DisplayName fieldholder.Value "bool"
            getBool fieldholder.Value

        // static member valueAsDecimal fieldholder = 
        //     let rec getDecimal fh =
        //         match fh with 
        //             | String s | Text s -> 
        //                 match Decimal.TryParse(s) with
        //                     | true, d -> d
        //                     | _ -> failwith <| sprintf "Expecting a decimal value for %s but got %s instead" fieldholder.DisplayName s
        //             //| Decimal d -> d
        //             // | Double d 
        //             | Float d ->  Convert.ToDecimal(d)
        //             | Int i ->  Convert.ToDecimal(i)
        //             | Bool b -> failwith <| sprintf "Expecting a decimal value for %s but got %b instead" fieldholder.DisplayName b
        //             | Hidden s -> getDecimal s
        //             | _ -> failwith <| sprintf "Cannot convert value for %s of %A to %s" fieldholder.DisplayName fieldholder.Value "decimal"
        //     getDecimal fieldholder.Value

        static member valueAsFloat fieldholder =
            let rec getDouble fh =
                match fh with 
                    | String s | Message s | Text s -> 
                        match Double.TryParse(s) with
                            | true, d -> d
                            | _ -> failwith <| sprintf "Expecting a decimal value for %s but got %s instead" fieldholder.DisplayName s
                    //| Decimal d -> Convert.ToDouble(d)
                    // | Double d 
                    | Password s -> failwith <| sprintf "Expecting a boolean value for %s but got %s instead" fieldholder.DisplayName "password"
                    | Float d ->  d.Value
                    | Int i ->  Convert.ToDouble(i)
                    | Bool b -> failwith <| sprintf "Expecting a decimal value for %s but got %b instead" fieldholder.DisplayName b
                    | Hidden s -> getDouble s
                    | _ -> failwith <| sprintf "Cannot convert value for %s of %A to %s" fieldholder.DisplayName fieldholder.Value "float"
            getDouble fieldholder.Value

        static member valueAsInt fieldholder =
            let rec getInt fh =
                match fh with 
                    | String s | Message s | Text s -> 
                        match Int32.TryParse(s) with
                            | true, i -> i
                            | _ -> failwith <| sprintf "Expecting a number value for %s but got %s instead" fieldholder.DisplayName s
                    //| Decimal d -> Convert.ToInt32(d)
                    // | Double d 
                    | Password s -> failwith <| sprintf "Expecting a boolean value for %s but got %s instead" fieldholder.DisplayName "password"
                    | Float d -> Convert.ToInt32(d.Value)
                    | Int i -> i
                    | TimeSpanInt (i,_) -> i
                    | Bool b -> failwith <| sprintf "Expecting a number value for %s but got %b instead" fieldholder.DisplayName b
                    | Hidden s -> getInt s
                    | _ -> failwith <| sprintf "Cannot convert value for %s of %A to %s" fieldholder.DisplayName fieldholder.Value "int"
            getInt fieldholder.Value        

        static member isHidden fieldholder =
            match fieldholder.Value with
                | Hidden _ -> true
                | _ -> false


type Msg = 
    | ValueChanged of FieldHolder


type ValidationMessages = {
    Required: string
}
    with 
        static member none = { Required= "" }
        static member default_ = { Required= "Required" }        

type FormHolder = {
    FormId: string
    Caption: string
    Fields: FieldHolder list
    ValidationMessages: ValidationMessages
    Validations: (FormHolder -> Result<bool,string>) list
    OnRefresh: (FieldHolder -> FormHolder -> FormHolder) option
}
    with 
        static member empty = { FormId= Guid.NewGuid().ToString(); Caption= "Loading..."; Fields= []; ValidationMessages= { Required= "" } ; Validations= [] ; OnRefresh= None }
        static member createSimple caption fieldHolders = {
                                                FormId= "formholder"
                                                Caption= caption
                                                Fields= fieldHolders
                                                ValidationMessages= ValidationMessages.default_
                                                Validations= []
                                                OnRefresh= None
                                            }
        static member addValidation func formHolder =
            { formHolder with Validations = List.append formHolder.Validations [ func ] }

        static member setStringLookup (holder:FormHolder) (fieldId:string)  (lookupVals:SelectOptionString list) =
            match holder.Fields |> List.tryFind (fun x -> x.FieldId = fieldId) with
            | Some f ->
                match f.Value with
                | SelectOption (v,_) -> 
                    { holder with Fields =
                                    holder.Fields
                                    |> List.map (fun x -> if x.FieldId = f.ControlId then { f with Value= SelectOption(v,lookupVals) }
                                                            else x ) } 
                | _ -> holder
            | None -> holder

        static member valueAsString (holder:FormHolder) (controlId:string) = 
            match holder.Fields |> List.tryFind (fun x -> x.FieldId = controlId) with
                | Some f -> FieldHolder.valueAsString f
                | None -> failwith <| sprintf "No value for %s was found" controlId 
        // static member valueAsDecimal (holder:FormHolder) (controlId:string) = 
        //     match holder.Fields |> List.tryFind (fun x -> x.FieldId = controlId) with
        //         | Some f -> FieldHolder.valueAsDecimal f
        //         | None -> failwith <| sprintf "No value for %s was found" controlId 
        static member valueAsFloat (holder:FormHolder) (controlId:string) = 
            match holder.Fields |> List.tryFind (fun x -> x.FieldId = controlId) with
                | Some f -> FieldHolder.valueAsFloat f
                | None -> failwith <| sprintf "No value for %s was found" controlId 
        static member valueAsInt (holder:FormHolder) (controlId:string) =
            match holder.Fields |> List.tryFind (fun x -> x.FieldId = controlId) with
                | Some f -> FieldHolder.valueAsInt f
                | None -> failwith <| sprintf "No value for %s was found" controlId 
        static member valueAsBoolean (holder:FormHolder) (controlId:string) =
            match holder.Fields |> List.tryFind (fun x -> x.FieldId = controlId) with
                | Some f -> FieldHolder.valueAsBool f
                | None -> failwith <| sprintf "No value for %s was found" controlId 

let jsonEncodeValue (valueHolder:ValueHolder) =
    let rec getJson holder= 
        match holder with
            | String str | Message str | Text str | Password str 
            | DateString str | DateTimeString str | TimeString str 
            | HtmlPreview str -> Encode.string str  
            //| Decimal flt -> Convert.ToDouble flt |> Encode.float  //Encode.decimal flt
            // | Double flt 
            | Float flt -> Encode.float (flt.Value)
            | Int i -> Encode.int i
            | TimeSpanInt (i,_) -> Encode.int i
            | Bool bl -> Encode.bool bl        
            | Hidden vh -> getJson vh
            | BitString (str,_)  
            | SelectManyOptions (str,_) -> Encode.string str
            | SelectOption (k,_) -> 
                match k with
                    | StringKey str -> Encode.string str
                    | IntKey i -> Encode.int i
                    | GuidKey g -> Encode.guid g
                    // | IntKey ik -> match Int32.TryParse ik with
                    //                 | true, i -> Encode.int i
                    //                 | _ ->  failwith <| sprintf "Expecting a number value for json but got %s instead" k.Key
    getJson valueHolder

let jsonEncodeValueList (fields: FieldHolder list) =
    Encode.object (
        fields
            |> List.map (fun x -> x.FieldId, jsonEncodeValue x.Value )
    )

let jsonEncodeForm (instance:FormHolder) = 
    instance.Fields 
        // |> (fun fhs -> printfn "Encoding Fields: %A" fhs ; fhs)
        |> jsonEncodeValueList

let inline formToType<'a> (fh:FormHolder) =
    fh
    |> (fun fh -> printfn "Converting to Form: %A" fh ; fh )    
    |> jsonEncodeForm 
    |> (fun v -> printfn "Json: %A" v ; v) 
    |> Thoth.Json.Encode.toString 4 
    |> (fun str -> printfn "Json: %s" str ; str) 
    |> (fun str -> Thoth.Json.Decode.Auto.fromString<'a>(str,CaseStrategy.PascalCase) )

let getFieldFromList (fields: FieldHolder list) (id:string) =
    fields |> List.filter (fun x -> x.ControlId = id) |> List.tryHead |> Option.defaultValue FieldHolder.empty

let getField (instance:FormHolder) (id:string) = 
    // instance.Fields |> List.filter (fun x -> x.ControlId = id) |> List.tryHead |> Option.defaultValue FieldHolder.empty
    getFieldFromList instance.Fields id

module TimeHandling =
    let posOr i def arr = arr |> Array.tryItem i |> Option.defaultValue def
    let padZeros str = 
        "00" + str |> (fun (s:string) -> s.Substring(s.Length - 1 - 1) )

    //let datestr, timestr = 
    let splitDateAndTime fh =
        fh  |> FieldHolder.valueAsString 
            |> (fun str -> str.Split(' ') ) 
            |> (fun arr -> 
                    arr |> posOr 0 (DateTime.Today.ToString("yyyy-MM-dd")), 
                        arr |> posOr 1 "00:00:00" )
    // let hours, mins, secs = 
    let splitTimeStr (timestr:string) = 
        let arr = timestr.Split(':')
        arr |> posOr 0 "00", arr |> posOr 1 "00", arr |> posOr 2 "00"

    let validateIntInRange (upper:int) (str:string) =
        match Int32.TryParse(str |> string) with   
            | true, n -> if n < upper && n >= 0 then Some n else None
            | false, _ -> None        

    let convertAllowableTimeInput (upper:int) (fallback:string) (str:string) = 
        let trimstr (s:string) =
            if s.Length > 2 then
                if s.StartsWith("0") then s.Substring(1)                
                else s.Substring(s.Length - 1 - 1)
            else s
        if str = "" then "00"
        else str |> trimstr |> validateIntInRange upper |> Option.map string |> Option.defaultValue fallback |> padZeros

    let showSeconds (layout:Layout) = 
        match layout with
            | Layout.Time tl -> tl = TimeLayout.HourMinuteSecond
            | _ -> false
                

module Update = 
    let updateFieldInList (fields: FieldHolder list) (newField: FieldHolder) =
        fields 
            |> List.map (
                fun x -> 
                    if x.ControlId = newField.ControlId && (ValueHolder.equalTypes newField.Value x.Value) then
                        newField
                    else if x.ControlId = newField.ControlId then
                        match newField.Value, x.Value with
                            | Text s, HtmlPreview _ -> { x with Value= HtmlPreview s }
                            | _, _ -> x
                    else x)

    let updateFieldByControlId (fields:FieldHolder list) (controlid:string) (newValue:ValueHolder) =
        fields |> List.map (fun x ->    
                                        if x.ControlId = controlid then 
                                            { x with Value= newValue }
                                        else x)

    let updateInForms (forms: FormHolder list) (field:FieldHolder) = 
        forms
            |> List.map (
                    fun form -> { form with Fields= updateFieldInList form.Fields field })

    let replaceField (fh:FormHolder) (newField:FieldHolder) =
        { fh with Fields=  fh.Fields 
                                |> List.map (fun x ->    
                                        if x.ControlId = newField.ControlId then 
                                            newField
                                        else x)
        }

    let updateField (frm:FormHolder) (newField:FieldHolder) =
        { 
            FormId= frm.FormId
            Caption= frm.Caption
            Fields= updateFieldInList frm.Fields newField
            ValidationMessages = frm.ValidationMessages
            Validations= frm.Validations
            OnRefresh= frm.OnRefresh
        }
            |> (fun fh -> frm.OnRefresh |> function | Some fn -> fn newField fh | None -> fh) 

    let replaceFields (newFields: FieldHolder list) formHolder =         
        printfn "Replacing Before: %A" formHolder
        let updated =
            newFields
                |> List.fold (fun fh next -> replaceField fh next) formHolder
        printfn "Replacing After: %A" updated
        updated

    let updateFloatField (f:FieldHolder) (newText:string) (lastVal:FloatValue) =
        // { ControlId= f.ControlId; FieldId = f.FieldId; FieldName= f.FieldName; Value= Text newText }
        let noLeadingZeros (str:string) = if str.Length > 1 && str.StartsWith("0") then str.Substring(1) else str
        // printfn "%s %A" newText lastVal
        if newText = "" then
            { f with Value= Float { Display= newText ; Value= 0. } }
        else
            match Double.TryParse(newText) with   
                | (true, d) ->
                    { f with Value = Float { Display= noLeadingZeros newText ; Value =  d } }
                | (false,_) -> 
                    { f with Value = Float lastVal }

    let updateIntField (f:FieldHolder) (newText:string) (lastVal:int) =
        // { ControlId= f.ControlId; FieldId = f.FieldId; FieldName= f.FieldName; Value= Text newText }
        match Int32.TryParse(newText) with
            | (true, dec) ->
                { f with Value = Int dec }
            | (false,_) -> 
                { f with Value = Int lastVal }

    let updateBitStringField (f:FieldHolder) newStr =
        match f.Value with
            | BitString (str,lst) -> 
                { f with Value= BitString (newStr, lst) }
            | _ -> failwith <| sprintf "Unable to update %s with new value %s" f.DisplayName newStr

    let updateStringOptionsField (f:FieldHolder) keyStr lst =
        match f.Value with
            // | RadioButtonsString (k,_) -> 
            //     { f with Value= RadioButtonsString ({ k with Key= keyStr },lst) }
            | SelectOption (k,_) -> 
                // { f with Value= SelectString ( { k with Key= keyStr },lst) }
                match k with 
                    | IntKey i -> 
                        { f with Value= SelectOption ( IntKey (Int32.Parse(keyStr)),lst) }
                    | StringKey s -> 
                        { f with Value= SelectOption ( StringKey keyStr,lst) }
                    | GuidKey g -> 
                        { f with Value= SelectOption (GuidKey g,lst) }
            | _ -> failwith <| sprintf "Invalid control type for %s with select options" f.DisplayName

    let updateTimeField (ohours:string option) (omins:string option) (osecs:string option) (lastVal:string) =
        //HACK: for some reason, ohours, omins . osecs were coming through as nulls
        // let ifNullOption opt = if isNull (opt :> Object) then None else opt
        // printfn "%s %A %A %A" lastVal ohours omins osecs
        let lhours, lmins, lsecs = TimeHandling.splitTimeStr lastVal
        match ohours, omins, osecs with
            | Some str, _, _ ->                                     
                sprintf "%s:%s:%s" (TimeHandling.convertAllowableTimeInput 24 lhours str) lmins lsecs
            | None, Some str, _ ->
                sprintf "%s:%s:%s" lhours (TimeHandling.convertAllowableTimeInput 60 lmins str) lsecs                
            | None, None, Some str ->
                sprintf "%s:%s:%s" lhours lmins (TimeHandling.convertAllowableTimeInput 60 lsecs str)
            | _, _, _ -> lastVal
    let updateTimeSpanIntField (f:FieldHolder) (ts:IntTimeSpan) =
        let mins = ts.Days * 24 * 60 + ts.Hours * 60 + ts.Minutes
        { f with Value= TimeSpanInt (mins,IntTimeSpan.empty) }

let updateValue (msg:Msg) (frm:FormHolder) : FormHolder = 
    match msg with
        | ValueChanged fld -> Update.updateField frm fld

//NB to avoid breaking changes
let update = updateValue

let fieldValueStr (fh:FieldHolder) =
    FieldHolder.valueAsString fh 

let validateRequired (fh:FieldHolder) =
    match fh.Behaviour with
        | Default | ReadOnly | Optional -> true
        | Required -> 
            if (fieldValueStr fh).Length > 0 then true
            else false

let validatedForm (fh:FormHolder) =        
    //the required fields are displayed in the controls so we don't need the error messages
    let inputValidations : Result<bool,string> = (fh.Fields |> List.forall validateRequired) |> Ok 
    fh.Validations
        |> List.map (
            fun func -> 
                try func fh 
                with e -> Error <| sprintf "Form Configuration Error - %s" e.Message
        )
        |> List.append [ inputValidations ]
        |> List.fold (
            fun state next -> 
                match state, next with 
                    | Ok b1, Ok b2 -> Ok (b1 && b2)
                    | Ok b, Error err -> Error [ err ]
                    | Error lst, Ok b -> Error lst
                    | Error lst, Error err -> lst @ [ err ] |> Error ) (Ok true)

module Validation =
    let matchingValues controlId1 controlId2 errorMessage formHolder =
        try
            printfn "%s" <| FormHolder.valueAsString formHolder controlId1
            printfn "%s" <| FormHolder.valueAsString formHolder controlId2
            if FormHolder.valueAsString formHolder controlId1 = FormHolder.valueAsString formHolder controlId2 then 
                Ok true
            else Error errorMessage
        with ex -> Error ex.Message
    let minimumLength minLength controlId1 errorMessage formHolder =
        if FormHolder.valueAsString formHolder controlId1 |> String.length >= minLength then 
            Ok true
        else Error errorMessage
    let validGuid controlId errorMessage formHolder = 
        match FormHolder.valueAsString formHolder controlId |> Guid.TryParse with
            | true, guid when guid <> Guid.Empty ->
                Ok true                
            | true, guid -> Error "No request reference found. Please re-send request"
            | false, guid -> Error "Invalid request"
    let validEmail controlId errorMessage formHolder =
        FormHolder.valueAsString formHolder controlId 
            |> (fun str -> str.ToCharArray())
            |> Array.fold (fun st nxt -> if nxt = '@' || nxt = '.' then st + (string nxt) else st) ""
            |> (fun str -> if str.Contains("@.") then Ok true else Error errorMessage)

module Input =
    let updateFieldValue (fh:FieldHolder) (v:ValueHolder) = { fh with Value = v } 
    let fieldStringInput (fh:FieldHolder) (styles:string) addins (validation:ValidationMessages) (trigger:FieldHolder -> unit) = 
        div [ Class ("form-group" |> addStyle styles) ] (
            [
                label [] [ str fh.DisplayName ]
                input [Id (idOf fh.FieldId); Type "text"; Class "form-control form-control-sm"; 
                        Value ( fh |> fieldValueStr ); 
                        HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                        OnChange (fun e -> String e.Value |> updateFieldValue fh |> trigger )  ]
                (if validateRequired fh |> not then
                    small [ Class "text-danger" ] [ str validation.Required ] // (sprintf "%s is required" fh.FieldName ) ]
                else
                    p [] [] )
            ] @ addins
        )
    let passwordStringInput (fh:FieldHolder) (styles:string) (validation:ValidationMessages) (trigger:FieldHolder -> unit) = 
        div [ Class ("form-group" |> addStyle styles) ] [
            label [] [ str fh.DisplayName ]
            input [Id (idOf fh.FieldId + "xxxx"); Type "password"; Class "form-control form-control-sm"; 
                    Value ( fh |> fieldValueStr ); 
                    HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                    OnChange (fun e -> Password e.Value |> updateFieldValue fh |> trigger ) ]
            (if validateRequired fh |> not then
                small [ Class "text-danger" ] [ str validation.Required ] // (sprintf "%s is required" fh.FieldName ) ]
            else
                p [] [] )
        ]

    let fieldTextInput (fh:FieldHolder) (styles:string) (validation:ValidationMessages) (trigger:FieldHolder -> unit) = 
        div [ Class ("form-group" |> addStyle styles) ] [
            label [] [ str fh.DisplayName ]
            // textarea [] []
            textarea [ Id (idOf fh.FieldId); Class "form-control form-control-sm"; 
                    DefaultValue ( fh |> fieldValueStr ); 
                    Rows 10;
                    OnChange (fun e -> Text (string e.Value) |> updateFieldValue fh |> trigger  ) ] [] //fh |> fieldValueStr |> str ]
            (if validateRequired fh |> not then
                small [ Class "text-muted" ] [ str validation.Required ] // (sprintf "%s is required" fh.FieldName ) ]
            else
                p [] [] )
        ]

    let fieldHiddenString (fh:FieldHolder) = 
        div [] [] //input [ Id (idOf fh.FieldId); Type "hidden"; Class "form-control form-control-sm"; Value ( fh |> fieldValueStr ) ] 

    let fieldFloatInput (fh:FieldHolder) (styles:string) (validation:ValidationMessages) (trigger:FieldHolder -> unit) = 
        let readFloatHolder = function | Float tup -> tup | _ -> FloatValue.zero
        div [ Class ("form-group" |> addStyle styles) ] [
            label [] [ str fh.DisplayName ]
            input [Id (idOf fh.FieldId); Type "number"; Class "form-control form-control-sm"; 
                    Value ( fh |> fieldValueStr ); 
                    HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);                    
                    OnChange (fun e -> trigger (Update.updateFloatField fh e.Value (readFloatHolder fh.Value) ) ) ]
            (if validateRequired fh |> not then
                small [ Class "text-danger" ] [ str validation.Required ] // (sprintf "%s is required" fh.FieldName ) ]
            else
                p [] [] )
        ]

    let fieldIntInput (fh:FieldHolder) (styles:string) (validation:ValidationMessages) (trigger:FieldHolder -> unit) = 
        let numbersOnly str = 
            let allowed = [ '-' ; '0' ; '1' ; '2' ; '3' ; '4' ; '5' ; '6' ; '7' ; '8' ; '9' ]
            [| for c in str do
                    if allowed |> List.tryFind (fun x -> x = c) |> Option.isSome then yield c
            |]
                |> (fun x -> (new String(x)) )
        div [ Class ("form-group" |> addStyle styles) ] [
            label [] [ str fh.DisplayName ]
            input [ Id (idOf fh.FieldId); Type "number"; Class "form-control form-control-sm"; 
                    Value ( fh |> fieldValueStr )
                    HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                    OnChange (fun e -> trigger (Update.updateIntField fh e.Value (FieldHolder.valueAsInt fh) ) ) ]
            (if validateRequired fh |> not then
                small [ Class "text-danger" ] [ str validation.Required ] // (sprintf "%s is required" fh.FieldName ) ]
            else
                p [] [] )
        ]

    let fieldBoolInput (fh:FieldHolder) (styles:string) (validation:ValidationMessages) (trigger:FieldHolder -> unit) = 
        let bval = (FieldHolder.valueAsBool fh)
        let checkEvent = (fun _ -> Bool (not bval) |> updateFieldValue fh |> trigger )
        div [ Class <| addStyle styles "form-group form-check" ; OnClick checkEvent ] [
            div [ Class "d-inline" ; Style [ PaddingRight "20px" ] ] [ str "" ]
            input [ Id fh.ControlId ; Type "checkbox"; Class "form-check-input form-control-sm"; 
                    Checked bval; 
                    OnChange checkEvent ]
            // , label [for (id_ name) ] [text name]
            label [ HtmlFor fh.ControlId ] [ str fh.DisplayName ]
            (if validateRequired fh |> not then
                small [ Class "text-danger" ] [ str validation.Required ] // (sprintf "%s is required" fh.FieldName ) ]
            else
                p [] [] )
        ]


    let fieldBitStringInput (fh:FieldHolder) (bitString:string*string list) (styles:string) (validation:ValidationMessages) (trigger:FieldHolder -> unit) =
        let isChecked index = match fst bitString |> (fun s -> s.ToCharArray() ) |> Array.tryItem index with
                                            | Some c -> c = '1'
                                            | None -> false 
        let displayName index = snd bitString |> List.tryItem index |> Option.defaultValue ""
        let controlid fh index = sprintf "%s%i" fh.ControlId index 
        let checkEvent index = ( fun _ -> (fst bitString).ToCharArray()
                                            |> Array.mapi (fun i x ->   if i = index then
                                                                            if isChecked index then '0' else '1'
                                                                        else x )
                                            |> (fun x -> new String(x) )
                                            |> Update.updateBitStringField fh 
                                            |> trigger )                                           
        let switch index name = 
            let cid = (idOf fh.FieldId) + (sprintf "%i" index )
            div [ Class "form-check" ] [
                // div [ Class "d-inline"; Style [ PaddingRight "20px" ] ] [ str "" ]
                input [ Id cid  ; Type "checkbox"; Class "form-check-input form-control-sm"; 
                        Checked <| isChecked index; 
                        OnChange <| checkEvent index ]
                // , label [for (id_ name) ] [text name]
                label [ OnClick <| checkEvent index ; HtmlFor cid ] [ str <| displayName index ]
                // (if validatedInput fh |> not then
                //     small [ Class "text-danger" ] [ str validation.Required ] // (sprintf "%s is required" fh.FieldName ) ]
                // else
                //     p [] [] )
            ]
        div [ Class <| addStyle styles "form-group" ] [
            label [] [ str fh.DisplayName ]
            div [] (                
                // (snd bitString) |> List.mapi (fun i x -> li [ Class "list-group-item" ] [ switch i x ] )
                (snd bitString) |> List.mapi (fun i x -> switch i x )                
            )
        ]
 
    let updateManySelection selected (key:string) =
        // let filtered = selected |> List.filter (fun x -> x <> key && key.EndsWith("*") |> not )
        let filtered = selected |> List.filter (fun x -> x <> key )
        let removeStarred = List.filter (fun (x:string) -> x.EndsWith("*") |> not)
        let settingOn = filtered.Length = selected.Length
        if settingOn && key.EndsWith("*") then
            [ key ]
        else if settingOn then
            (selected |> removeStarred) @ [ key ]
        else filtered

    let selectManyStrings (fh:FieldHolder) (selections:string*SelectOptionString list) (styles:string) (validation:ValidationMessages) (trigger:FieldHolder -> unit) =
        let selected= fst selections |> (fun str -> str.Split([| ";" |], StringSplitOptions.RemoveEmptyEntries)) |> Array.toList
        printfn "%A" selected
        let isChecked key = selected |> List.exists (fun s -> s = key) 
        // let displayName index = snd selections |> List.tryItem index |> Option.defaultValue ""
        let controlid fh index = sprintf "%s%i" fh.ControlId index 
        let checkEvent key = ( fun _ ->     
                                            updateManySelection selected key
                                            |> String.concat ";"
                                            |> (fun lst -> 
                                                    printfn "%s" lst
                                                    { fh with Value = SelectManyOptions (lst,snd selections) } )
                                            |> trigger )                                           

        let switch opt = 
            let cid = (idOf fh.FieldId) + (sprintf "%s" opt.Key )
            div [   Class "form-check" 
                    // OnClick <| checkEvent opt.Key 
            ] [                               
                input [ Id cid
                        Type "checkbox"
                        Class "form-check-input form-control-sm"                         
                        //DefaultChecked <| isChecked opt.Key 
                        Checked <| isChecked opt.Key
                        // Disabled true
                        OnClick <| checkEvent opt.Key
                ]
                label [     HtmlFor cid 
                            Disabled true
                ] [ str opt.Value ]
            ]
        div [ Class <| addStyle styles "form-group" ] [
            label [] [ str fh.DisplayName ]
            div [] (                
                // (snd bitString) |> List.mapi (fun i x -> li [ Class "list-group-item" ] [ switch i x ] )
                (snd selections) |> List.map switch                
            )
        ]

    let buttonsManyStrings (fh:FieldHolder) (selections:string*SelectOptionString list) (styles:string) (validation:ValidationMessages) (trigger:FieldHolder -> unit) =
        let alloptions = snd selections
        let selected= fst selections |> (fun str -> str.Split([| ";" |], StringSplitOptions.RemoveEmptyEntries)) |> Array.toList
        let isChecked key = selected |> List.exists (fun s -> s = key) 
        // let displayName index = snd selections |> List.tryItem index |> Option.defaultValue ""
        let controlid fh index = sprintf "%s%i" fh.ControlId index 
        let checkEvent key = ( fun _ -> //let filtered = selected |> List.filter (fun x -> x <> key)
                                        printfn "selected: %s" key
                                        // (if selected.Length = filtered.Length then // add to selection
                                        //     if key.EndsWith("*") then [ key ]   //only one selection allowed if starred
                                        //     else selected |> List.append [ key ]
                                        // else filtered)      //remove from selection
                                        updateManySelection selected key
                                            |> String.concat ";"
                                            |> (fun selected -> 
                                                    { fh with Value = SelectManyOptions (selected,snd selections) } )
                                            |> trigger )                                           

        let switch i opt = 
            let id i = sprintf "%s%i" fh.ControlId i 
            button [    Class <| "mr-1 mb-1 btn btn-sm " + (if (isChecked opt.Key) then "btn-primary" else "btn-outline-primary")
                        Type "button"
                        Id <| id i
                        Value opt.Key
                        OnClick (checkEvent opt.Key) 
            ] [
                str opt.Value
            ]
        div [ Class <| addStyle styles "form-group" ] [
            label [] [ str fh.DisplayName ]
            div [] (                
                // (snd bitString) |> List.mapi (fun i x -> li [ Class "list-group-item" ] [ switch i x ] )
                alloptions |> List.mapi switch                
            )
        ]

    let dateStringInput (fh:FieldHolder) (styles:string) (validation:ValidationMessages) (trigger:FieldHolder -> unit) =
        div [ Class ("form-group" |> addStyle styles) ] [
            label [] [ str fh.DisplayName ]
            input [ Id (idOf fh.FieldId); Type "date"; Class "form-control form-control-sm"; 
                    Value ( fh |> fieldValueStr )
                    HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                    OnChange (fun e -> DateString e.Value |> updateFieldValue fh |> trigger ) ]
            (if validateRequired fh |> not then
                small [ Class "text-danger" ] [ str validation.Required ] // (sprintf "%s is required" fh.FieldName ) ]
            else
                p [] [] )
        ]

    let dateTimeStringInput (fh:FieldHolder) (styles:string) (validation:ValidationMessages) (trigger:FieldHolder -> unit) =
        let datestr, timestr = TimeHandling.splitDateAndTime fh 
        let updateReturnValue datestr timestr = 
                sprintf "%s %s" datestr timestr
                    |> DateTimeString |> updateFieldValue fh |> trigger 
        let hours, mins, secs = TimeHandling.splitTimeStr timestr
        div [ Class ("form-group" |> addStyle styles) ] [
            label [] [ str fh.DisplayName ]
            div [ Class "form-row" ] [
                div [ Class "col-6" ] [
                    div [ Class "form-row" ] [
                        input [ Id (idOf fh.FieldId); Type "date"; Class "form-control form-control-sm"; 
                                Value ( datestr )
                                HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                                OnChange (fun e -> DateString e.Value |> updateFieldValue fh |> trigger  ) ]                    
                    ]
                    small [ Class "text-secondary" ] [ str "date" ]
                ]
                div [ Class "col-6" ] [                    
                    div [ Class "form-row" ] (
                        [
                            div [ Class "col-4 text-right" ] [
                                    input [ Id (idOf fh.FieldId + "h"); Type "text"; 
                                            Class "form-control form-control-sm text-right w-100"; 
                                            Value hours 
                                            HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                                            OnChange (
                                                fun e -> 
                                                    Update.updateTimeField (Some e.Value) None None timestr 
                                                        |> updateReturnValue datestr
                                            ) ]
                                    small [ Class "text-secondary w-100" ] [ str "hr" ]
                            ]
                            // p [ Class "ml-1 mr-1" ] [ str ":" ]
                            //minutes
                            div [ Class "col-4 text-right" ] [
                                // div [ Class "form-row" ] [
                                    input [ Id (idOf fh.FieldId + "m"); Type "text"; 
                                            Class "form-control form-control-sm text-right w-100"; 
                                            Value mins
                                            HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                                            OnChange (
                                                fun e -> 
                                                    Update.updateTimeField None (Some e.Value) None timestr 
                                                        |> updateReturnValue datestr
                                            )]
                                    small [ Class "text-secondary w-100" ] [ str "min" ]                                
                            ]
                        ]
                        @
                        (if TimeHandling.showSeconds fh.Layout then
                            [
                                div [ Class "col-4 text-right" ] [
                                    // label [] [ str " : " ]
                                    input [ Id (idOf fh.FieldId + "m"); Type "text"; 
                                            Class "form-control form-control-sm text-right w-100"; 
                                            Value secs
                                            HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                                            OnChange (
                                                fun e -> 
                                                    Update.updateTimeField None None (Some e.Value) timestr 
                                                        |> updateReturnValue datestr
                                            )]
                                    small [ Class "text-secondary w-100" ] [ str "sec" ]
                                ]
                            ]
                        else [] )
                        // []
                    )
                    // []
                ]
            ]
            (if validateRequired fh |> not then
                small [ Class "text-danger" ] [ str validation.Required ] // (sprintf "%s is required" fh.FieldName ) ]
            else
                p [] [] )
        ]

    let timeStringInput (fh:FieldHolder) (timestr:string) (styles:string) (validation:ValidationMessages) (trigger:FieldHolder -> unit) =
        let hours, mins, secs = TimeHandling.splitTimeStr timestr
        //printfn "timestr: %s:%s:%s" hours mins secs
        div [ Class ("form-group" |> addStyle styles) ] [
            label [] [ str fh.DisplayName ]
            //hours
            div [ Class "form-row" ] (                
                [
                    div [ Class "col-4 text-right" ] [
                        input [ Id (idOf fh.FieldId + "h"); Type "text"; 
                                Class "form-control form-control-sm w-100 text-right"; 
                                Value hours 
                                HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                                OnChange (fun e ->  Update.updateTimeField (Some e.Value) None None timestr 
                                                        |> TimeString |> updateFieldValue fh |> trigger  ) ]
                        small [ Class "text-secondary w-100" ] [ str "hr" ]
                    ]
                    div [ Class "col-4 text-right" ] [
                        //minutes
                        input [ Id (idOf fh.FieldId + "m"); Type "text"; 
                                Class "form-control form-control-sm w-100 text-right"; 
                                Value mins
                                HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                                OnChange (fun e ->  Update.updateTimeField None (Some e.Value) None timestr 
                                                        |> TimeString |> updateFieldValue fh |> trigger  ) ]
                        small [ Class "text-secondary w-100" ] [ str "min" ]
                    ]
                ]
                @
                (if TimeHandling.showSeconds fh.Layout then
                    [
                        div [ Class "col-4 text-right" ] [
                        //minutes
                            input [ Id (idOf fh.FieldId + "s"); Type "text"; 
                                    Class "form-control form-control-sm w-100 text-right"; 
                                    Value secs
                                    HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                                OnChange (fun e ->  Update.updateTimeField None None (Some e.Value) timestr 
                                                        |> TimeString |> updateFieldValue fh |> trigger  ) ]
                            small [ Class "text-secondary w-100" ] [ str "sec" ]
                        ]
                    ]
                else [] )
            )
            // div [ Class "form-row text-right" ] [
            //     small [ Class "text-secondary w-100" ] [ str "hours" ]
            //     // p [ Class "ml-1 mr-1" ] [ str ":" ]
            //     small [ Class "text-secondary w-100" ] [ str "minutes" ]
            // ]
            (if validateRequired fh |> not then
                small [ Class "text-danger" ] [ str validation.Required ] // (sprintf "%s is required" fh.FieldName ) ]
            else
                p [] [] )
        ]

    // let radioButtonsInput<'a when 'a : equality> (fh:FieldHolder) (options:'a*SelectOption<'a> list) (styles:string) 
    let buttonsStringInput (fh:FieldHolder) (options:SelectKey*SelectOptionString list) (styles:string) 
                                    (validation:ValidationMessages) (trigger:FieldHolder -> unit) =
        let alloptions = snd options
        let selected = fst options
        let withMatches =   alloptions
                                |> List.mapi (fun i x -> i, x.Key = SelectKey.asString selected, x)
        //let third (_, _, c) = c
        let radio (i,isSelected,(option:SelectOptionString)) = 
            let id i = sprintf "%s%i" fh.ControlId i 
            button [    Class <| "mr-1 mb-1 btn btn-sm " + (if isSelected then "btn-primary" else "btn-outline-primary")
                        Type "button"
                        Id <| id i
                        Value option.Key
                        OnClick (fun e -> trigger (Update.updateStringOptionsField fh e.Value alloptions ) ) 
            ] [
                str option.Value
            ]
        div [ Class ("form-group" |> addStyle styles) ] (
            div [ Class "row" ] (
                withMatches 
                    |> List.map radio
            )
                |> List.singleton
                |> List.append [ label [] [ str fh.DisplayName ] ]
        )

    let radioButtonsStringInput (fh:FieldHolder) (options:SelectKey*SelectOptionString list) (styles:string) 
                                    (validation:ValidationMessages) (trigger:FieldHolder -> unit) =
        let alloptions = snd options
        let selected = fst options
        let withMatches =   alloptions
                                |> List.mapi (fun i x -> i, x.Key = SelectKey.asString selected, x)
        let third (_, _, c) = c
        let radio (i,isSelected,(option:SelectOptionString)) = 
            let id i = sprintf "%s%i" fh.ControlId i 
            div [ Class "form-check" ] [
                input [ Type "radio" ; Id <| id i ;
                            Class "form-check-input" ;
                            HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly) ;
                            Value option.Key ;
                            Checked isSelected ;
                            OnChange (fun e -> trigger (Update.updateStringOptionsField fh e.Value (snd options) ) ) ]
                label [ Class "form-check-label" ; HtmlFor (id i) ] [ str option.Value ] 
            ]
        div [ Class ("form-group" |> addStyle styles) ] (            
            withMatches 
                |> List.map radio
                |> List.append [ label [] [ str fh.DisplayName ] ]
        )

    let selectStringInput (fh:FieldHolder) (options:SelectKey*SelectOptionString list) (styles:string) 
                                    (validation:ValidationMessages) (trigger:FieldHolder -> unit) =
        //printfn "%A" options
        let alloptions = snd options
        let selected = fst options
        let emptyOption = { Key= "0" ; Value = "Select One ..." } 
        let withMatches =   alloptions
                                |> List.append (if alloptions |> List.exists (fun o -> o.Key = "0") then [] else [ emptyOption ] )
                                |> List.mapi (fun i x -> i, x.Key = SelectKey.asString selected, x)                                   
        // let selectedKey optstr = snd options 
        //                             |> List.tryFind (fun x -> x.Value = optstr) 
        //                             |> Option.defaultValue emptyOption
        //                             |> (fun x -> x.Key)

        let third (_, _, c) = c
        let showOption (i,selected,(o:SelectOptionString)) = 
            // let id i = sprintf "%s%i" fh.ControlId i 
            option [    //Selected selected
                        Value o.Key
            ] [ str o.Value ]
        div [ Class ("form-group" |> addStyle styles) ] [
            label [ Class "form-check-label" ; HtmlFor fh.ControlId ] [ str fh.DisplayName ] 
            select [    Id fh.ControlId
                        Class "form-control"              
                        OnChange (fun e -> 
                                    //printfn "%A" e.Value
                                    //printfn "%A" <| (updateStringOptionsField fh e.Value (snd options) )
                                    trigger (Update.updateStringOptionsField fh e.Value (snd options) ) ) 
                        // Value (selected.Key) //(fst options |> selectedKey)
                        Value (SelectKey.asString selected) //(fst options |> selectedKey)
                ] (
                withMatches 
                    |> List.map showOption

                )
        ]

    let timeSpanInt (fh:FieldHolder) (mins:int) (styles:string) (validation:ValidationMessages) (trigger:FieldHolder -> unit) =
        let numbersOnly str = 
            let allowed = [ '0' ; '1' ; '2' ; '3' ; '4' ; '5' ; '6' ; '7' ; '8' ; '9' ]
            [| for c in str do
                    if allowed |> List.tryFind (fun x -> x = c) |> Option.isSome then yield c
            |]
                |> (fun x -> (new String(x)) )
                |> (fun x -> match Int32.TryParse(x) with
                                | true, i -> i
                                | _, _ -> 0 )
        // let hours, mins = 
        //     let time= FieldHolder.valueAsString fh
        //     let arr = time.Split(':')
        //     arr.[0], arr.[1]
        let timeSpan = 
            let fmins = Convert.ToDouble(mins)    
            {   Days= fmins / (24. * 60.) |> int
                //Hours= fmins % 24. |> (fun x -> Math.Floor(x/60.) ) |> int
                Hours= Math.Floor(fmins/60.) |> (fun x -> x % 24.) |> int
                Minutes= fmins % 60. |> int
            } 
        div [ Class ("form-group" |> addStyle styles) ] [
            label [] [ str fh.DisplayName ]
            //hours
            div [ Class "form-row" ] [ 
                input [ Id (idOf fh.FieldId + "d"); Type "text"; 
                        Class "form-control form-control-sm w-25"; 
                        Value timeSpan.Days //<| string timeSpan.Days
                        HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                        OnChange (fun e -> trigger (Update.updateTimeSpanIntField fh { Days= e.Value |> numbersOnly ; Hours= timeSpan.Hours ; Minutes= timeSpan.Minutes } ) ) ]
                p [ Class "ml-1 mr-1" ] [ str ":" ]
                input [ Id (idOf fh.FieldId + "h"); Type "text"; 
                        Class "form-control form-control-sm w-25"; 
                        Value timeSpan.Hours //<| string timeSpan.Hours 
                        HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                        OnChange (fun e -> trigger (Update.updateTimeSpanIntField fh { Days= timeSpan.Days ; Hours= e.Value |> numbersOnly ; Minutes= timeSpan.Minutes } ) ) ]
                p [ Class "ml-1 mr-1" ] [ str ":" ]
                //minutes
                input [ Id (idOf fh.FieldId + "m"); Type "text"; 
                        Class "form-control form-control-sm w-25"; 
                        Value timeSpan.Minutes //<| string timeSpan.Minutes
                        HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                        OnChange (fun e -> trigger (Update.updateTimeSpanIntField fh { Days= timeSpan.Days ; Hours= timeSpan.Hours; Minutes= e.Value |> numbersOnly } ) ) ]
            ]
            div [ Class "form-row" ] [
                small [ Class "text-secondary w-25" ] [ str "days" ]
                p [ Class "ml-1 mr-1" ] [ str ":" ]
                small [ Class "text-secondary w-25" ] [ str "hours" ]
                p [ Class "ml-1 mr-1" ] [ str ":" ]
                small [ Class "text-secondary w-25" ] [ str "minutes" ]
                // input [ Id (idOf fh.FieldId + "h"); Type "text"; 
                //         Class "form-control form-control-sm w-25"; 
                //         Value hours 
                //         HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                //         OnChange (fun e -> trigger (updateTimeField fh (Some e.Value) None timestr  ) ) ]
                // p [ Class "ml-1 mr-1" ] [ str ":" ]
                //minutes
                // input [ Id (idOf fh.FieldId + "m"); Type "text"; 
                //         Class "form-control form-control-sm w-25"; 
                //         Value mins
                //         HTMLAttr.ReadOnly (fh.Behaviour = ReadOnly);
                //         OnChange (fun e -> trigger (updateTimeField fh None (Some e.Value) timestr ) ) ]
            ]

            (if validateRequired fh |> not then
                small [ Class "text-danger" ] [ str validation.Required ] // (sprintf "%s is required" fh.FieldName ) ]
            else
                p [] [] )
        ]


module Display = 
    let fieldMessage (fh:FieldHolder) (styles:string) (validation:ValidationMessages) = 
        div [ Class ("form-group text-secondary" |> addStyle styles) ] [
            label [] [ str fh.DisplayName ]
            p [] [ str (fh |> fieldValueStr) ]
        ]

    let HtmlPreview (fh:FieldHolder) (styles:string) (validation:ValidationMessages) = 
        div [ Class "form-group" ] [
            label [] [ str fh.DisplayName ]
            div [
                Class "border-secondary" 
                DangerouslySetInnerHTML { __html = (fh |> fieldValueStr ) }
            ] []
        ]


// let styledCheckBox name value styles (trigger:bool -> unit) =
//     div [ Class <| addStyle styles "form-group form-check" ] [
//         div [ Class "d-inline"; Style [ PaddingRight "20px" ] ] [ str "" ]
//         input [ Id (idOf name) ; Type "checkbox"; Class "form-check-input form-control-sm"; 
//                 Checked value; 
//                 OnChange (fun _ -> trigger (not value) ) ]
//         // , label [for (id_ name) ] [text name]
//         label [] [ str name ]
//     ]

let getHelp fh = 
    match fh.Help with
        | NoHelp -> []
        | Help (control,content) -> 
            match control with
                | HelpIcon -> [ Helpers.View.helpIcon content ]
                | HelpButton -> [ Helpers.View.helpButton content ]

let getInput (field:FieldHolder) colspan (validation:ValidationMessages) dispatch =
    let addins = getHelp field
    match field.Value with
        | String str -> Input.fieldStringInput field colspan addins validation (ValueChanged >> dispatch)
        | Message str -> Display.fieldMessage field colspan validation
        | Text str -> Input.fieldTextInput field colspan validation (ValueChanged >> dispatch)
        | Password str -> Input.passwordStringInput field colspan validation (ValueChanged >> dispatch)
        | Hidden str -> Input.fieldHiddenString field
        // | Date str -> 
        // | Decimal flt -> Input.fieldDecimalInput field "col-sm-6" validation (ValueChanged >> dispatch)
        // | Double flt 
        | Float flt -> Input.fieldFloatInput field colspan validation (ValueChanged >> dispatch)
        | Int i -> Input.fieldIntInput field colspan validation (ValueChanged >> dispatch)
        | Bool b -> Input.fieldBoolInput field colspan validation (ValueChanged >> dispatch)
        | BitString (str,lst) -> Input.fieldBitStringInput field (str,lst) colspan validation (ValueChanged >> dispatch)
        | DateString str -> Input.dateStringInput field colspan validation (ValueChanged >> dispatch)
        | DateTimeString str -> Input.dateTimeStringInput field colspan validation (ValueChanged >> dispatch)
        | TimeString str -> Input.timeStringInput field str colspan validation (ValueChanged >> dispatch)
        // | RadioButtonsString (sel,options) -> Input.radioButtonsStringInput field (sel,options) colspan validation (ValueChanged >> dispatch)
        | SelectOption (sel,options) -> 
            match field.Layout with 
                | Select layout when layout = SelectLayout.RadioButtons ->
                // | Layout.RadioButtons ->
                    Input.radioButtonsStringInput field (sel,options) colspan validation (ValueChanged >> dispatch)
                // | Layout.Buttons -> 
                | Select layout when layout = SelectLayout.Buttons ->
                    Input.buttonsStringInput field (sel,options) colspan validation (ValueChanged >> dispatch)
                | _ ->
                    Input.selectStringInput field (sel,options) colspan validation (ValueChanged >> dispatch)
        | SelectManyOptions (sel,options) -> 
            match field.Layout with 
                // | Layout.Buttons -> 
                | SelectMany layout when layout = SelectManyLayout.Buttons -> 
                    Input.buttonsManyStrings field (sel,options) colspan validation (ValueChanged >> dispatch)                    
                | _ ->
                    Input.selectManyStrings field (sel,options) colspan validation (ValueChanged >> dispatch)
        | TimeSpanInt (i,_) -> Input.timeSpanInt field i colspan validation (ValueChanged >> dispatch)
        | HtmlPreview str -> Display.HtmlPreview field colspan validation


module FormLayout=
    let inForm elements = 
        form [] elements

    let formCaption (caption:string) =
        div [] [
            div [ Class "container bg-secondary text-white rounded" ] [ 
                h3 [ Style [ PaddingTop "4px"; PaddingBottom "4px" ] ] [ str caption]
            ]
            div [ Class "d-block"; Style [ PaddingTop "8px" ] ] []
        ]

    let formSubCaption (caption:string) =
        div [] [
            div [ Class "container bg-info text-white rounded" ] [ 
                h4 [ Style [ PaddingTop "4px"; PaddingBottom "4px" ] ] [ str caption]
            ]
            div [ Class "d-block"; Style [ PaddingTop "8px" ] ] []
        ]

    let inFormWithCaption caption elements = 
        div [ Class "container" ] [
            div [ Class "border border-secondary rounded"; Style [ Padding "5px" ] ] [            
                formCaption caption            
                div [ Class "container" ] [
                    form [] elements                                
                    div [ Class "d-block"; Style [ PaddingTop "10px" ] ] []
                ]
            ]
        ]


module View=
    let formWithColspan (form:FormHolder) colspan dispatch = 
        FormLayout.inFormWithCaption form.Caption [
            div [ Class "d-block"; Style [ PaddingBottom "10px" ] ] [
            ]
            // formSubCaption "Item Information"
            div [ Class "form-row" ] (
                form.Fields
                    |> List.map (fun x -> getInput x colspan form.ValidationMessages dispatch)
            )
            div [] (
                match validatedForm form with
                    | Ok b -> []
                    | Error errs -> errs |> List.map (fun err -> p [ Class "text-danger" ] [ str err ] )
            )
        ]

    let form (form:FormHolder) dispatch = 
        formWithColspan form "col-sm-6" dispatch
        // inFormWithCaption form.Caption [
        //     div [ Class "d-block"; Style [ PaddingBottom "10px" ] ] [
        //     ]
        //     // formSubCaption "Item Information"
        //     div [ Class "form-row" ] (
        //         form.Fields
        //             |> List.map (fun x -> getInput x "col-sm-6" form.ValidationMessages dispatch)
        //     )
        // ]

    let formDisabled (form:FormHolder) dispatch =
        FormLayout.inFormWithCaption form.Caption [
            div [ Class "d-block"; Style [ PaddingBottom "40px" ] ] [
            ]
            // fieldset [ Disabled true ] [
                // formSubCaption "Item Information"
            div [ Class "form-row" ] (
                form.Fields
                    |> List.map (fun x -> { x with Behaviour= ReadOnly } )
                    |> List.map (fun x -> getInput x "col-sm-6" form.ValidationMessages dispatch)
            )
            // ]
        ]

    let borderlessWithColspan (form:FormHolder) colspan dispatch = 
        form.Fields
            |> List.map (fun x -> getInput x colspan form.ValidationMessages dispatch)
            |> FormLayout.inForm

    let borderless (form:FormHolder) dispatch =
        borderlessWithColspan form "col-sm-6" dispatch 

